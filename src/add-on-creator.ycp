/* ------------------------------------------------------------------------------
 * Copyright (c) 2006 Novell, Inc. All Rights Reserved.
 *
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of version 2 of the GNU General Public License as published by the
 * Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program; if not, contact Novell, Inc.
 *
 * To contact Novell about this file by physical or electronic mail, you may find
 * current contact information at www.novell.com.
 * ------------------------------------------------------------------------------
 */

/**
 * File:	clients/add-on-creator.ycp
 * Package:	Configuration of add-on-creator
 * Summary:	Main file
 * Authors:	Jiri Suchomel <jsuchome@suse.cz>
 *
 * $Id$
 *
 * Main file for add-on-creator configuration. Uses all other files.
 */

{

/***
 * <h3>Configuration of add-on-creator</h3>
 */

textdomain "add-on-creator";

/* The main () */
y2milestone ("----------------------------------------");
y2milestone ("AddOnCreator module started");

import "AddOnCreator";
import "CommandLine";
import "Directory";
import "FileUtils";

include "add-on-creator/wizards.ycp";

void ReportMissingFile (string file) {
    // error message, %1 is path
    Report::Error (sformat (_("File %1 does not exist."), file));
}

void ReportMissingDir (string dir) {
    // error message, %1 is path
    Report::Error (sformat (_("Directory %1 does not exist."), dir));
}

// helper for parsing command line data regarding iso creation
map ParseISOData (map<string,any> options) {

    map current_product	= $[];
    current_product["iso"]	= haskey (options, "create_iso");
    if (haskey (options, "iso_name"))
    {
	current_product["iso"]	= true;
	current_product["iso_name"]	= options["iso_name"]:"";
    }
    if (haskey (options, "iso_output_dir"))
    {
	current_product["iso"]	= true;
	current_product["iso_path"]	= options["iso_output_dir"]:"";
    }
    return current_product;
}

// helper for parsing command line data regarding product signing
map ParseGPGData (map<string,any> options) {

    map current_product	= $[];
    string key	= options["gpg_key"]:"";
    if (key != "")
	current_product["gpg_key"] = key;
    string passphrase	= options["passphrase"]:"";
    if (passphrase == "" && haskey (options, "passphrase_file"))
    {
	string file = options["passphrase_file"]:"";
	if (FileUtils::Exists (file))
	{
	    string pass	= (string) SCR::Read (.target.string, file);
	    if (pass != nil)
		passphrase = pass;
	}
	else
	{
	    ReportMissingFile (file);
	}
    }
    else if (passphrase == "" && key != "")
    {
	passphrase	=
	    // question on command line
	    CommandLine::PasswordInput (sformat (_("Passphrase for key %1:"),
	    current_product["gpg_key"]:""));
    }
    AddOnCreator::passphrases[key]	= passphrase;
    current_product["ask_for_passphrase"]	= true;
    current_product["resign_packages"]	= haskey (options, "resign_packages");
    return current_product;
}

/**
 * General function for creating new add-on
 */
boolean Create (map<string,any> options ) {

    map current_product	= AddOnCreator::current_product;
    if (!haskey (options, "output_dir"))
    {
	// error message
	Report::Error (_("Path to output directory is missing."));
	return false;
    }
    else
	current_product["base_output_path"]	= options["output_dir"]:"";

    // now we can import different content file if it was provided
    if (haskey (options, "content"))
    {
	string file	= options["content"]:"";
	if (FileUtils::Exists (file))
	{
	    list<map> content = AddOnCreator::ReadContentFile (file);
	    if (content != nil)
	    {
		AddOnCreator::content	= content;
		AddOnCreator::UpdateContentMap (content);
	    }
	}
	else
	{
	    ReportMissingFile (file);
	    if (!AddOnCreator::clone)
		return false;
	}
    }
    if (haskey (options, "product_file"))
    {
	string file	= options["product_file"]:"";
	if (FileUtils::Exists (file))
	{
	    AddOnCreator::product_xml	=
		AddOnCreator::ReadProductXML (file);
	    AddOnCreator::product_info	=
		AddOnCreator::GetProductInfo (AddOnCreator::product_xml, false);
	}
	else
	{
	    ReportMissingFile (file);
	    return false;
	}
    }
    if (haskey (options, "package_descriptions_dir"))
    {
	string dir	= options["package_descriptions_dir"]:"";
	if (FileUtils::Exists (dir))
	{
	    // find all packages.langcode in dir and import them
	    map out = (map) SCR::Execute (.target.bash_output,
		sformat ("ls -A1 %1/packages.* 2>/dev/null", dir));
	    map packages_descr	= current_product["packages_descr"]:$[];
	    foreach (string file, splitstring (out["stdout"]:"", "\n"), {
		list f		= splitstring (file, ".");
		string lang	= f[size(f)-1]:"en";
		if (lang == "gz")
		{
		    if (size (f) > 2) lang	= f[size(f)-2]:"en";
		    else return;
		}
		if (file == "" || lang == "DU" || lang == "FL") return;
		packages_descr[lang] = AddOnCreator::ReadPackagesFile (file);
	    });
	    current_product["packages_descr"]	= packages_descr;
	}
	else
	{
	    ReportMissingDir (dir);
	}
    }
    if (haskey (options, "patterns_dir"))
    {
	string dir	= options["patterns_dir"]:"";
	if (FileUtils::Exists (dir))
	{
	    // find all packages.langcode in dir and import them
	    map out = (map) SCR::Execute (.target.bash_output,
		sformat ("ls -A1 %1/*.pat 2>/dev/null", dir));
	    map patterns	= $[];
	    foreach (string f, splitstring(out["stdout"]:"", "\n"), {
		if (f == "") return;
		foreach (map pat, AddOnCreator::ReadPatternsFile (f), {
		    if (pat != $[])
		    {
			string full_name	= pat["Pat"]:"";
			list<string> pt		= splitstring (full_name, " ");
			if (full_name != "")
			{
			    pat["name"]		= pt[0]:"";
			    pat["version"]	= pt[1]:"";
			    pat["release"]	= pt[2]:"";
			    pat["arch"]		= pt[3]:"";
			    patterns[full_name]	= pat;
			}
		    }
		});
	    });
	    current_product["patterns"]	= patterns;
	}
	else
	{
	    ReportMissingDir (dir);
	}
    }
    current_product	= union (current_product, ParseISOData (options));

    if (haskey (options, "info"))
    {
	string file	= options["info"]:"";
	if (FileUtils::Exists (file))
	{
	    string info	= (string) SCR::Read (.target.string, file);
	    if (info != nil)
		current_product["info"]	= info;
	}
	else
	    ReportMissingFile (file);
    }
    if (haskey (options, "extra_prov"))
    {
	string file	= options["extra_prov"]:"";
	if (FileUtils::Exists (file))
	{
	    string extra	= (string) SCR::Read (.target.string, file);
	    if (extra != nil)
		current_product["extra_prov"]	= extra;
	}
	else
	    ReportMissingFile (file);
    }
    if (haskey (options, "license"))
    {
	string file	= options["license"]:"";
	if (FileUtils::Exists (file))
	{
	    integer pos = findlastof (file, ".");
	    string tmpdir	= Directory::tmpdir;
	    if (substring (file, pos) == ".zip")
	    {
		if (!FileUtils::Exists ("/usr/bin/unzip"))
		{
		    // error message, missing tool
		    Report::Error (_("/usr/bin/unzip does not exists"));
		}
		else
		{
		    SCR::Execute (.target.bash_output,
			sformat ("/usr/bin/unzip -o %1 -d %2", file, tmpdir));
		}
	    }
	    else // let's try to unzip without checking file name and type...
	    {
		SCR::Execute (.target.bash_output,
		    sformat ("/bin/tar -zxf %1 -C %2", file, tmpdir));
	    }
	    map out = (map) SCR::Execute (.target.bash_output,
		sformat ("ls -A1 %1/license*.txt 2>/dev/null", tmpdir));
	    foreach (string f, splitstring(out["stdout"]:"", "\n"), {
		if (f == "") return;
		string name	= substring (f, findlastof (f, "/") + 1);
		if (issubstring (name, ".txt"))
		    name	= regexpsub (name, "^(.*)\.txt$", "\\1");
		y2milestone ("Importing license file '%1'", f);
		string cont	= (string) SCR::Read (.target.string, f);
		if (cont != nil)
		    current_product["license_files",name] = cont;
	    });
	}
	else
	{
	    ReportMissingFile (file);
	}
    }

    if (haskey (options, "workflow"))
    {
	string file	= options["workflow"]:"";
	if (FileUtils::Exists (file))
	{
	    current_product["workflow_path"]	= file;
	}
	else
	{
	    ReportMissingFile (file);
	}
    }

    if (haskey (options, "y2update"))
    {
	string file	= options["y2update"]:"";
	if (FileUtils::Exists (file))
	{
	    current_product["y2update_path"]	= file;
	}
	else
	{
	    ReportMissingFile (file);
	}
    }
    else if (haskey (options, "y2update_packages_dir"))
    {
	string dir = options["y2update"]:"";
	if (FileUtils::Exists (dir))
	{
	    map out = (map) SCR::Execute (.target.bash_output,
		sformat ("ls -A1 %1/*.rpm 2>/dev/null", dir));
	    current_product["y2update_packages"] = filter (
		string f, splitstring(out["stdout"]:"", "\n"), ``(f != "")
	    );
	}
	else
	{
	    ReportMissingDir (dir);
	}
    }
    current_product["changelog"]	= haskey (options, "changelog");

    current_product["generate_release_package"]		= true;
    if (haskey (options, "no_release_package"))
    {
	current_product["generate_release_package"]	= false;
    }
    if (!haskey (options, "do_not_sign"))
    {
	current_product     = union (current_product, ParseGPGData (options));
    }
    if (!FileUtils::Exists (current_product["base_output_path"]:"")) {
	SCR::Execute (.target.mkdir, current_product["base_output_path"]:"");
    }
    AddOnCreator::current_product	= current_product;
    AddOnCreator::selected_product	= -1; // new product
    AddOnCreator::CommitCurrentProduct ();

    if (haskey (options, "do_not_build"))
	return true;

    // now, build the product that was added last: current product data
    // must be initialized again:
    AddOnCreator::current_product	=
      AddOnCreator::add_on_products[size(AddOnCreator::add_on_products)-1]:$[];
    // fill again other global values cleared by CommitCurrentProduct
    AddOnCreator::SelectProduct (AddOnCreator::current_product);

    return AddOnCreator::BuildAddOn ();
}

/**
 * Command line handler for creating new add-on from scratch
 */
boolean CreateAddOn (map<string,any> options) {

    AddOnCreator::clone	= false;
    string rpm_dir	= options["rpm_dir"]:"";
    if (rpm_dir == "")
    {
	// error message
	Report::Error (_("Path to directory with packages is missing."));
	return false;
    }
    if (substring (rpm_dir, size (rpm_dir) - 1, 1) != "/")
	rpm_dir	= rpm_dir + "/";
    AddOnCreator::current_product	= $[
	"rpm_path"	: rpm_dir
    ];
    if (!haskey (options, "content"))
    {
	// error message
	Report::Error (_("Path to content file is missing."));
	return false;
    }
    AddOnCreator::FillContentDefaults ();
    return Create (options);
}

/**
 * Command line handler for clonig existing add-on
 */
boolean CloneAddOn (map<string,any> options) {

    AddOnCreator::clone	= true;
    AddOnCreator::import_path	= options["existing"]:"";
    if (AddOnCreator::import_path == "")
    {
	// error message
	Report::Error (_("Path to existing Add-On is missing."));
	return false;
    }
    AddOnCreator::generate_descriptions	=
	haskey (options, "generate_descriptions");
    AddOnCreator::ImportExistingProduct (AddOnCreator::import_path);
    AddOnCreator::FillContentDefaults (); // TODO not necessary when content is provided?
    return Create (options);
}

/**
 * Command line handler for signing existing Add-On
 */
boolean SignAddOn (map<string,any> options) {

    AddOnCreator::only_sign_product	= false;
    if (!haskey (options, "addon_dir"))
    {
	// error message
	Report::Error (_("Path to directory with Add-On is missing."));
	return false;
    }
    else
    {
	AddOnCreator::current_product["base_output_path"] =
	    options["addon_dir"]:"";
    }

    // we need to import same data from existing add-on (e.g. for iso name)
    AddOnCreator::ImportExistingProduct (options["addon_dir"]:"");
    AddOnCreator::FillContentDefaults ();

    map current_product	= AddOnCreator::current_product;

    current_product     = union (current_product, ParseGPGData (options));
    current_product	= union (current_product, ParseISOData (options));
    AddOnCreator::only_sign_product	= true;
    AddOnCreator::current_product	= current_product;
    AddOnCreator::BuildAddOn ();
    return false;
    // no write needed (configs were not modified, or there was only one-time
    // modification: iso, gpg info)
}

/**
 * Command line handler for listing existing Add-On configurations
 */
boolean ListAddOns (map<string,any> options) {

    list<map> add_on_products	= AddOnCreator::add_on_products;

    integer i	= 1;
    foreach (map add_on, add_on_products, {
	map cont	= add_on["content_map"]:$[];
	// command line summary, %1 is order, %2 product name
	CommandLine::Print (sformat (_("(%1) Product Name: %2"),
	    i, cont["NAME"]:""));
	// command line summary
	CommandLine::Print (sformat (_("\tVersion: %1"), cont["VERSION"]:""));
	// command line summary
	CommandLine::Print (sformat (_("\tInput directory: %1"),
	    add_on["rpm_path"]:""));
	CommandLine::Print (sformat (_("\tOutput directory: %1"),
	    add_on["base_output_path"]:""));
	if (add_on["patterns"]:$[] != $[])
	    // command line summary, %1 is comma-separated list
	    CommandLine::Print (sformat (_("\tPatterns: %1"), mergestring (
		maplist (string pat, map p, add_on["patterns"]:$[],``(pat)),
		", "))
	    );
	i	= i + 1;
    });
    return false; // no write needed
}

/**
 * Command line handler for building new addon
 */
boolean BuildAddOnHandler (map<string,any> options) {

    list<map> add_on_products	= AddOnCreator::add_on_products;
    if (size (add_on_products) == 0)
    {
	// command line message, do not translate 'create', 'clone'
	Report::Error (_("There is no add-on product configuration present. Create a new one using the 'create' or 'clone' commands."));
	return false;
    }
    integer number	= options["number"]:0;
    if (number < 1)
    {
	if (size (add_on_products) == 1)
	    number	= 0;
	else
	{
	    // error message
	    Report::Error (_("Specify the add-on product that should be built."));
	    return false;
	}
    }
    // !!! numbers are shown starting from 1, list is indexed from 0 !!!
    map product	= add_on_products[number - 1]:$[];

    product     = union (product, ParseISOData (options));
    // if the product should be signed (based on config) ParseGPGData should
    // take care of asking for password
    if (product["ask_for_passphrase"]:false && !haskey (options, "gpg_key"))
	options["gpg_key"]	= product["gpg_key"]:"";
    product     = union (product, ParseGPGData (options));

    // only set "generate" when requested, otherwise the saved info is used
    if (haskey (options, "changelog"))
	product["changelog"]	= true;

    // CLI option could replace the saved one
    if (haskey (options, "no_release_package"))
	product["generate_release_package"]	= false;

    AddOnCreator::SelectProduct (product);

    AddOnCreator::PrepareBuild ();
    AddOnCreator::BuildAddOn ();
    return false;
    // no write needed (configs were not modified, or there was only one-time
    // modification: iso, generated)
}

/**
 * Command line handler for deleting addon config
 */
boolean DeleteAddOn (map<string,any> options) {

    list<map> add_on_products	= AddOnCreator::add_on_products;
    if (size (add_on_products) == 0)
    {
	// command line message
	Report::Error (_("There is no add-on product configuration present."));
	return false;
    }
    integer number	= options["number"]:0;
    if (number < 1)
    {
	// error message
	Report::Error (_("Specify the add-on product configuration that should be deleted."));
	return false;
    }
    // !!! numbers are shown starting from 1, list is indexed from 0 !!!
    AddOnCreator::add_on_products       = remove (add_on_products, number - 1);
    return true;
}

map cmdline_description = $[
    "id"	: "add-on-creator",
    // Command line help text for the add-on-creator module
    "help"	: _("Creator for add-on products"),
    "guihandler"        : AddOnCreatorSequence,
    "initialize"        : AddOnCreator::Read,
    "finish"            : AddOnCreator::Write,
    "actions"           : $[
	"create"	: $[
	    "handler"	: CreateAddOn,
	    // command line help text for 'create' action
	    "help"	: _("Create and build a new add-on product."),
	],
	"clone"		: $[
	    "handler"	: CloneAddOn,
	    // command line help text for 'clone' action
	    "help"	: _("Create and build a new add-on product based on an existing one."),
	],
	"sign"		: $[
	    "handler"	: SignAddOn,
	    // command line help text for 'sign' action
	    "help"	: _("Sign unsigned Add-On Product"),
	],
	"list"		: $[
	    "handler"   : ListAddOns,
	    // command line help text for 'list' action
	    "help"	: _("List available add-on product configurations."),
	],
	"build"		: $[
	    "handler"	: BuildAddOnHandler,
	    // command line help text for 'create' action
	    "help"	: _("Build an add-on product from the selected configuration."),
	],
	"delete"	: $[
	    "handler"	: DeleteAddOn,
	    // command line help text for 'create' action
	    "help"	: _("Delete the selected add-on product configuration."),
	],
    ],
    "options"		: $[
	"rpm_dir"	: $[
	    // command line help text for 'rpm_dir' option
	    "help"	: _("Path to directory with packages"),
	    "type"	: "string"
	],
	"content"	: $[
	    // command line help text for 'content' option (do not translate 'content', it's a name)
	    "help"	: _("Path to content file"),
	    "type"	: "string"
	],
	"existing"	: $[
	    // command line help text for 'existing' option
	    "help"	: _("Path to directory with existing Add-On Product"),
	    "type"	: "string"
	],
	"generate_descriptions"	: $[
	    // command line help text for 'generate_descriptions' option
	    "help"	: _("Generate new package descriptions (do not copy)"),
	],
	"package_descriptions_dir"	: $[
	    // command line help text for 'package_descriptions_dir' option
	    "help"	: _("Path to directory with package descriptions"),
	    "type"	: "string"
	],
	"patterns_dir"	: $[
	    // command line help text for 'patterns_dir' option
	    "help"	: _("Path to directory with patterns definitions"),
	    "type"	: "string"
	],
	"output_dir"	: $[
	    // command line help text for 'output_dir' option
	    "help"	: _("Path to the output directory"),
	    "type"	: "string"
	],
	"create_iso"	: $[
	    // command line help text for 'create_iso' option
	    "help"	: _("Create the ISO image"),
	],
	"iso_name"	: $[
	    // command line help text for 'iso_name' option
	    "help"	: _("Name of the output ISO image"),
	    "type"	: "string",
	],
	"iso_output_dir"	: $[
	    // command line help text for 'output_dir' option
	    "help"	: _("Path to the output directory for ISO image"),
	    "type"	: "string"
	],
	"do_not_sign"	: $[
	    // command line help text for 'do_not_sign' option
	    "help"	: _("Do not sign the product"),
	],
	"gpg_key"	: $[
	    // command line help text for 'gpg_key' option
	    "help"	: _("GPG key ID used to sign a product"),
	    "type"	: "string",
	],
	"passphrase"	: $[
	    // command line help text for 'passphrase' option
	    "help"	: _("Passphrase to unlock GPG key"),
	    "type"	: "string",
	],
	"passphrase_file"	: $[
	    // command line help text for 'passphrase_file' option
	    "help"	: _("Path to file with the passphrase for GPG key"),
	    "type"	: "string",
	],
	"resign_packages"	: $[
	    // command line help text for 'passphrase' option
	    "help"	: _("Resign all packages with selected key"),
	],
	"workflow"	: $[
	    // command line help text for 'workflow' option
	    "help"	: _("Path to workflow definition file (installation.xml)"),
	    "type"	: "string",
	],
	"y2update"	: $[
	    // command line help text for 'y2update' option
	    "help"	: _("Path to workflow dialogs archive (y2update.tgz)"),
	    "type"	: "string",
	],
	"y2update_packages_dir"	: $[
	    // command line help text for 'y2update_packages_dir' option
	    "help"	: _("Path to directory with YaST packages to form the workflow"),
	    "type"	: "string",
	],
	"license"	: $[
	    // command line help text for 'license' option
	    "help"	: _("Path to file with license texts (license.zip or license.tar.gz)"),
	    "type"      : "string",
	],
	"info"	: $[
	    // command line help text for 'info' option
	    "help"	: _("Path to file with 'info' text (media.1/info.txt)"),
	    "type"      : "string",
	],
	"extra_prov"	: $[
	    // command line help text for 'extra_prov' option
	    "help"	: _("Path to file with additional dependencies (EXTRA_PROV)"),
	    "type"      : "string",
	],
	"addon_dir"	: $[
	    // command line help text for 'addon-dir' option
	    "help"	: _("Path to directory with Add-On Product"),
	    "type"	: "string"
	],
	"do_not_build"	: $[
	    // command line help text for 'do_not_build' option
	    "help"	: _("Do not build the product, only save new configuration"),
	],
	"number"	: $[
	    // help text for 'number' option; do not translate 'list'
	    "help"	: _("Number of the selected add-on (see 'list' command for product numbers)."),
	    "type"	: "integer"
	],
	"changelog"	: $[
	    // command line help text for 'changelog' option
	    "help"	: _("Generate a Changelog file."),
	],
	"no_release_package"	: $[
	    // command line help text for 'no_release_package' option
	    "help"	: _("Do not generate the release package"),
	],
	"product_file"	: $[
	    // command line help text for 'product_file' option
	    "help"	: _("Path to file with the product description (*.prod)"),
	    "type"	: "string",
	],
    ],
    "mappings"		: $[
	"create"	: [ "content", "rpm_dir", "package_descriptions_dir",
	    "patterns_dir", "output_dir", "create_iso", "iso_name", "gpg_key",
	    "passphrase", "passphrase_file", "workflow", "y2update",
	    "y2update_packages_dir", "license", "do_not_sign", "iso_output_dir",
	    "resign_packages", "info", "extra_prov", "do_not_build",
	    "changelog", "no_release_package", "product_file",
	],
	"clone"		: [ "existing", "generate_descriptions", "content",
	    "package_descriptions_dir", "patterns_dir", "output_dir",
	    "create_iso", "iso_name",
	    "gpg_key", "passphrase", "passphrase_file", "workflow", "y2update",
	    "y2update_packages_dir", "license", "do_not_sign", "iso_output_dir",
	    "resign_packages", "info", "extra_prov", "do_not_build",
	    "changelog", "no_release_package", "product_file",
	],
	"sign"		: [ "addon_dir", "gpg_key", "passphrase",
	    "passphrase_file", "create_iso", "iso_name", "iso_output_dir",
	    "resign_packages"
	],
	"build"		: [
	    "number", "gpg_key", "passphrase", "passphrase_file",
	    "resign_packages", "create_iso", "iso_name", "iso_output_dir",
	    "changelog", "no_release_package",
	],
	"delete"	: [
	    "number"
	],
	"list"		: [
	],
    ]
];

any ret = CommandLine::Run(cmdline_description);

/* Finish */
y2milestone("AddOnCreator module finished with %1", ret);
y2milestone("----------------------------------------");

return ret;

/* EOF */
}
