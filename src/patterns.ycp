/* ------------------------------------------------------------------------------
 * Copyright (c) 2006-2012 Novell, Inc. All Rights Reserved.
 *
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of version 2 of the GNU General Public License as published by the
 * Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program; if not, contact Novell, Inc.
 *
 * To contact Novell about this file by physical or electronic mail, you may find
 * current contact information at www.novell.com.
 * ------------------------------------------------------------------------------
 */

/**
 * File:	include/add-on-creator/patterns.ycp
 * Package:	Add-On Creator
 * Summary:	Dialogs for patterns and selections
 * Authors:	Jiri Suchomel <jsuchome@suse.cz>
 *
 * $Id$
 */

{

textdomain "add-on-creator";

import "Label";
import "Popup";
import "String";
import "Wizard";
import "AddOnCreator";

include "add-on-creator/helps.ycp";

// how to show and handle pattern keys
map pattern_descr	= AddOnCreator::pattern_descr;

string create_full_name (map pattern) {
    return AddOnCreator::CreatePatternFullName (pattern, false);
}


// new pattern map - maybe add default values to pattern_descr map?
map new_pattern_old (string name) {
    map ret = mapmap (string key, map descr, (map<string,map>)pattern_descr, {
	return $[ key : haskey (descr, "defval") ? descr["defval"]:nil : "" ];
    });
    ret["name"]	= name;
    ret["Pat"]	= create_full_name (ret);
    return ret;
}

// new pattern map - maybe add default values to pattern_descr map?
map new_pattern (map pattern) {
    map ret = mapmap (string key, map descr, (map<string,map>)pattern_descr, {
	return $[ key : haskey (descr, "defval") ? descr["defval"]:nil : "" ];
    });
    foreach (string key, any val, (map<string,any>) pattern, {
	ret[key]	= val;
    });
    ret["Pat"]	= create_full_name (ret);
    return ret;
}

// add new pattern: get the identification (currently only name)
// return its name
//string AddPattern (list<string> conflicts) {
map AddPattern (map<string,list> conflicts) {

    map ret	= $[];

    UI::OpenDialog( `opt(`decorated), `HBox (`HSpacing(1), `VBox (
	`HBox (
	    // text entry label
	    `InputField (`id ("name"), `opt (`hstretch), _("&Name of the New Pattern")),
	    // combo box label
	    `ComboBox (`id ("arch"), _("&Architecture"),
		maplist (string v, pattern_descr["arch","allowed_values"]:[], ``(v))
	    )
	),
	`HBox (
	    // text entry label
	    `InputField (`id ("version"), `opt (`hstretch), _("&Version")),
	    // text entry label
	    `InputField (`id ("release"), `opt (`hstretch), _("&Release"))
	),
	`ButtonBox (
	    `PushButton(`id(`ok),`opt(`default,`key_F10),Label::OKButton()),
	    `PushButton(`id(`cancel),`opt (`key_F9), Label::CancelButton())
	)
    ), `HSpacing(1)));
    UI::SetFocus (`id("name"));
    UI::ChangeWidget (`id ("name"), `ValidChars, String::CAlnum () + "-_=.");
    while (true)
    {
	any result = UI::UserInput ();
	if (result == `cancel)
	{
	    break;
	}
	if (result == `ok)
	{
	    string name	= (string) UI::QueryWidget (`id ("name"), `Value);
	    string arch	= (string) UI::QueryWidget (`id ("arch"), `Value);
	    if (name == "")
	    {
		break;
	    }
	    if (contains (conflicts[name]:[], arch))
	    {
		// popup message
		Popup::Error (_("Such pattern already exists.
Choose a different name or architecture."));
		continue;
	    }
	    foreach (string key, ["name", "version", "release", "arch"], {
		string val = (string) UI::QueryWidget (`id (key), `Value);
		if (val != "")
		    ret[key]	= val;
	    });
	    break;
	}
    }
    UI::CloseDialog ();
    return ret;
}

// edit the key and value in pattern description
map AddPatternValue (list conflicts) {

    map ret		= $[];
    // textentry label
    string label	= _("&Value");
    string help	= mergestring (maplist (string k, ["Des", "Sum", "Cat"], {
	return sformat ("<p><b>%1</b></p>%2",
		AddOnCreator::pattern_descr[k,"label"]:"",
		AddOnCreator::pattern_descr[k,"lang_help"]:"");
    }), "<br>");
    UI::OpenDialog( `opt(`decorated), `HBox(
	`HSpacing(1),
	`VBox(
	    `VSpacing (0.5),
	    `RadioButtonGroup (`id(`rd),
		`Left(`HVSquash(`VBox (
		    `Left (`RadioButton(`id("Des"), `opt (`notify),
			_("&Description"), true)),
		    `Left (`RadioButton(`id("Sum"), `opt (`notify),
			_("&Summary"))),
		    `Left (`RadioButton(`id("Cat"), `opt (`notify),
			_("Ca&tegory")))
		)))
	    ),
	    // combo label
	    `Left (`ComboBox (`id(`lang), `opt(`editable), _("&Language Code"),
		AddOnCreator::GetLangCodes (false))
	    ),
	    `ReplacePoint (`id(`rp),
		`MultiLineEdit(`id(`val), label, "")
	    ),
	    `HBox(
		`PushButton(`id(`ok),`opt(`default,`key_F10),Label::OKButton()),
		`PushButton(`id(`cancel),`opt (`key_F9), Label::CancelButton()),
		`PushButton(`id(`help),`opt (`key_F2), Label::HelpButton())
	    )
	),
	`HSpacing(1)
    ));
    UI::SetFocus (`id("Des"));
    while (true)
    {
	any result = UI::UserInput ();
	if (result == `cancel)
	{
	    ret	= $[];
	    break;
	}
	string val = (string) UI::QueryWidget (`id(`val), `Value);
	if (result == "Des")
	{
	    UI::ReplaceWidget (`id(`rp),
		`MultiLineEdit(`id(`val), label, val));
	}
	if (result == "Sum" || result == "Cat")
	{
	    UI::ReplaceWidget (`id(`rp),
		`TextEntry (`id(`val), label, value2string (val)));
	}
	if (result == `help)
	{
	    // Heading for help popup window
	    Popup::LongText (_("Help"), `RichText (help), 50, 14);
	}
	if (result == `ok)
	{
	    string key	= sformat ("%1.%2",
		UI::QueryWidget (`id(`rd), `Value),
		UI::QueryWidget (`id(`lang), `Value));
	    if (contains (conflicts, key))
	    {
		// popup message
		Popup::Error (_("A key with this name already exists.
Choose a different one."));
		continue;
	    }
	    ret	= $[
		"key"	: key,
		"value"	: val
	    ];
	    break;
	}
    }
    UI::CloseDialog ();
    return ret;
}

/**
 * Dialog for editing patterns
 * @return dialog result
 */
any PatternsDialog() {

    map current_product		= AddOnCreator::current_product;
    string import_path		= current_product["rpm_path"]:"";
    map<string,map> patterns	= current_product["patterns"]:$[];
    string content_patterns	= AddOnCreator::content_map["PATTERNS"]:"";
    list<string> proposed_patterns	= splitstring (content_patterns, " ");

    // helper for generation of table items
    list get_pattern_items (map pattern) {
	list ret	= [];
	foreach (string key, any value, (map<string,any>) pattern,
	{
	    map pat	= pattern_descr[key]:$[];
	    if (pat == $[])
	    {
		string shortkey	= substring (key,0,3);
		pat		= pattern_descr[shortkey]:$[];
		pat["label"]	= pat["label"]:"" + sformat (" (%1)",
		    substring (key, 4));
	    }
	    if (pat != $[] && pat["label"]:"" != "")
	    {
		ret = add (ret, `item (
		    `id(key), pat["label"]:"", value2string (value))
		);
	    }
	});
	return ret;
    }

    list get_patterns_items () {
	return maplist (string full_name, map pattern, patterns, {
	    string name	= pattern["name"]:"";
	    return `item (`id (full_name), name, full_name);
	});
    }


    // dialog caption
    string caption = _("Editor for Patterns");

    term contents = `HBox (`HSpacing (), `VBox(
        `VSpacing (0.5),
	`VWeight (1, `Table (`id(`patterns), `opt(`notify, `immediate),
		// table header
	    `header(_("Name of the Pattern"),
		// table header
		_("Full Name")
	    ), get_patterns_items ()
	)),
        `HBox (
            `PushButton (`id(`new_pt), `opt(`key_F3), Label::NewButton()),
	    // button label
            `PushButton (`id(`import_pt), `opt(`key_F4), _("I&mport")),
            `PushButton (`id(`delete_pt), `opt(`key_F5), Label::DeleteButton()),
	    `HStretch()
	),
	`VWeight (2, `Table (`id(`pattern), `opt(`notify), `header(
	    // table header 1/2
	    _("Attribute"),
	    // table header 2/2
	    _("Value")),
	    []
	)),
        `HBox (
            `PushButton (`id(`add), `opt(`key_F6), Label::AddButton ()),
            `PushButton (`id(`edit), `opt(`key_F7), Label::EditButton ()),
	    `PushButton (`id(`delete), `opt(`key_F8), Label::DeleteButton ()),
            `HStretch (),
	    // check box label
	    `CheckBox (`id (`required), `opt (`notify, `key_F8), _("R&equired pattern"), false)
	),
	`VSpacing (0.5)
    ), `HSpacing ());

    Wizard::SetContentsButtons(caption, contents, HELPS["patterns"]:"",
	    Label::BackButton(), Label::NextButton());
    UI::SetFocus (`id(`patterns));
    string current_pattern =
	(string)UI::QueryWidget (`id(`patterns),`CurrentItem);
    map current_pattern_map	= patterns[current_pattern]:$[];
    if (patterns[current_pattern]:nil != nil)
    {
	UI::ChangeWidget (`id(`pattern), `Items,
	    get_pattern_items (patterns[current_pattern]:$[]));
	UI::ChangeWidget (`id(`required), `Value,
	    contains (proposed_patterns, current_pattern_map["name"]:""));
    }
    foreach (symbol w, [ `delete_pt, `edit, `add, `delete, `required ], {
	UI::ChangeWidget (`id (w), `Enabled, patterns != $[]);
    });

    symbol ret	= nil;
    while(true) {

	ret	= (symbol) UI::UserInput();

	map<string,list> conflicts	= $[];
	if (ret == `new_pt || ret == `edit || ret == `pattern)
	{
	    foreach (string pat, map p, patterns, {
		string name	= p["name"]:"";
		if (haskey (conflicts, name))
		    conflicts[name]	= add (conflicts[name]:[], p["arch"]:"");
		else
		    conflicts[name]     = [ p["arch"]:"" ];
	    });
	}
	if (ret == `new_pt) {
	    map new_pt	= AddPattern (conflicts);
	    if (new_pt != $[])
	    {
		new_pt			= new_pattern (new_pt);
		string full_name	= new_pt["Pat"]:"";
		patterns[full_name]	= new_pt;
		UI::ChangeWidget(`id(`patterns),`Items, get_patterns_items());
		UI::ChangeWidget(`id(`patterns),`CurrentItem, full_name);
	    }
	}
	else if (ret == `import_pt) {
	    string file = UI::AskForExistingFile (import_path, "*.pat *.pat.gz",
		// popup for file selection dialog
		_("Existing Pattern")
	    );
	    if (file != nil)
	    {
		map short2full	= mapmap (string full, map p, patterns, {
		    return $[
			p["name"]:"" + " " + p["arch"]:"" : full
		    ];
		});
		list<map> pats	= AddOnCreator::ReadPatternsFile (file);
		string full_name	= "";
		foreach (map pat, pats, {
		    full_name		= pat["Pat"]:"";
		    list<string> pt	= splitstring (full_name, " ");
		    if (full_name != "")
		    {
			pat["name"]	= pt[0]:"";
			pat["version"]	= pt[1]:"";
			pat["release"]	= pt[2]:"";
			pat["arch"]	= pt[3]:"";
			string short	= pt[0]:"" + " " + pt[3]:"";
			// replace existing pattern with same name and arch
			if (haskey (short2full, short))
			{
			    y2internal ("replacing pattern %1", short2full[short]:"");
			    patterns	= remove (patterns, short2full[short]:"");
			}
			patterns[full_name]	= pat;
		    }
		});
		UI::ChangeWidget(`id(`patterns), `Items, get_patterns_items());
		if (full_name != "")
		    UI::ChangeWidget(`id(`patterns), `CurrentItem, full_name);
		import_path	= file;
	    }
	}
	else if (ret == `delete_pt) {
	    string sel = (string)UI::QueryWidget (`id(`patterns),`CurrentItem);
	    if (sel != nil)
	    {
		patterns	= remove (patterns, sel);
		UI::ChangeWidget(`id(`patterns),`Items, get_patterns_items());
		UI::SetFocus (`id (`patterns));
	    }
	}
	if (contains ([`new_pt, `import_pt, `delete_pt], ret))
	{
	    foreach (symbol s, [`delete_pt, `edit, `add, `delete, `required], {
		UI::ChangeWidget (`id(s), `Enabled, patterns != $[]);
	    });
	    ret = `patterns;
	    if (ret != `delete_pt)
		UI::SetFocus (`id(`pattern));
	}
	string sel = (string)UI::QueryWidget (`id(`patterns),`CurrentItem);
	if (ret == `patterns) {
	    if (sel != current_pattern)
	    {
		current_pattern	= sel;
		current_pattern_map	= patterns[current_pattern]:$[];
		UI::ChangeWidget (`id(`pattern), `Items,
		    get_pattern_items (current_pattern_map));
		UI::ChangeWidget (`id(`required), `Value,
		    size (patterns) > 0 &&
		    contains (proposed_patterns, current_pattern_map["name"]:""));
	    }
	}
	else if (ret == `add) {
	    map new_val	= AddPatternValue (maplist (
		string k, any a, (map<string,any>) patterns[sel]:$[], ``(k))
	    );
	    if (new_val != $[])
	    {
		patterns[sel,new_val["key"]:""]	= new_val["value"]:"";
		UI::ChangeWidget (`id(`pattern), `Items,
		    get_pattern_items (patterns[sel]:$[]));
		UI::ChangeWidget (`id(`required), `Value, false);
	    }
	    UI::SetFocus (`id(`pattern));
	}
	else if (ret == `delete) {
	    string key	= (string)UI::QueryWidget (`id(`pattern),`CurrentItem);
	    patterns[sel]	= remove (patterns[sel]:$[], key);
	    UI::ChangeWidget (`id(`pattern), `Items,
		get_pattern_items (patterns[sel]:$[]));
	    UI::SetFocus (`id(`pattern));
	}
	else if (ret == `edit || ret == `pattern) {
	    string key	= (string)UI::QueryWidget (`id(`pattern),`CurrentItem);
	    map pat	= pattern_descr[key]:$[];
	    if (pat == $[])
	    {
		string shortkey = substring (key,0,3);
		pat             = pattern_descr[shortkey]:$[];
		pat["label"]    =
		    pat["label"]:"" + sformat (" (%1)", substring(key,4));
		pat["help"]	= pat["lang_help"]:pat["help"]:"";
	    }

	    map pattern		= patterns[sel]:$[];

	    any val = EditValue (
		union (pat, $[ "value" : pattern[key]:nil ]),
		"pattern"
	    );
	    if (val != nil)
	    {
		if (key == "arch")
		{
		    boolean conflict	= false;
		    foreach (string p, list archs, conflicts, {
			if (contains (archs, val))
			{
			    conflict	= true;
			    break;
			}
		    });
		    if (conflict)
		    {
			// error message
			Popup::Error (_("Such pattern already exists.
Choose a different architecture."));
			continue;
		    }
		}
		else if (!pattern_descr[key,"adapt_name"]:false)
		{
		    patterns[sel,key]	= val;
		}
		UI::ChangeWidget(`id(`pattern),`Item(key,1),value2string (val));
	    }
	    if (pattern_descr[key,"adapt_name"]:false)
	    {
		// key in the map was changed, generate affected items again
		pattern[key]		= val;
		string full_name	= create_full_name (pattern);
		pattern["Pat"]		= full_name;
		patterns		= remove (patterns, sel);
		patterns[full_name]	= pattern;
		UI::ChangeWidget(`id(`patterns),`Items, get_patterns_items());
	    }
	    UI::SetFocus (`id(`pattern));
	}
	else if (ret == `required)
	{
	    string name	= patterns[sel,"name"]:"";
	    if (UI::QueryWidget (`id (`required), `Value) == true)
	    {
		if (!contains (proposed_patterns, name))
		    proposed_patterns	= add (proposed_patterns, name);
	    }
	    else if (contains (proposed_patterns, name))
	    {
		proposed_patterns = filter (string p, proposed_patterns,
		    ``(name != p));
	    }
	}
        else if (ret == `next) {
	    AddOnCreator::current_product["patterns"]		= patterns;
	    content_patterns	= mergestring (proposed_patterns, " ");
	    if (AddOnCreator::content_map["PATTERNS"]:"" != content_patterns)
	    {
		integer i		= 0;
		foreach (map entry, AddOnCreator::content, {
		    if (entry["key"]:"" == "PATTERNS")
			AddOnCreator::content[i,"value"]= content_patterns;
		    i	= i + 1;
		});
		AddOnCreator::content_map["PATTERNS"]	= content_patterns;
	    }
	    break;
	}
	else if (ret == `back) {
            break;
        }
	else if(ret == `abort || ret == `cancel) {
	    if(ReallyAbort()) break;
	    continue;
	}
    }
    return ret;
}

}//EOF
