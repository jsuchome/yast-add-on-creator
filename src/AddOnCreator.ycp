/* ------------------------------------------------------------------------------
 * Copyright (c) 2006 Novell, Inc. All Rights Reserved.
 *
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of version 2 of the GNU General Public License as published by the
 * Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program; if not, contact Novell, Inc.
 *
 * To contact Novell about this file by physical or electronic mail, you may find
 * current contact information at www.novell.com.
 * ------------------------------------------------------------------------------
 */

/**
 * File:	modules/AddOnCreator.ycp
 * Package:	Configuration of add-on-creator
 * Summary:	AddOnCreator settings, input and output functions
 * Authors:	Jiri Suchomel <jsuchome@suse.cz>
 *
 * $Id$
 *
 * Representation of the configuration of add-on-creator.
 * Input and output routines.
 */

{

module "AddOnCreator";
textdomain "add-on-creator";

import "Arch";
import "Directory";
import "FileUtils";
import "Label";
import "Mode";
import "Package";
import "PackageSystem";
import "PackagesDescr";
import "Popup";
import "Progress";
import "Report";
import "String";

/**
 * where the configurations are stored
 */
string add_on_products_file	= Directory::vardir +"/add_on_products.ycp";

/**
 * list of all configured AddOn products
 */
global list<map> add_on_products	= [];

/**
 * map of the Add-On product currently in use
 */
global map current_product		= $[
    // path to output directory
    "base_output_path"	: "",
    // path to directory with RPM's
    "rpm_path"		: nil,
    // path to directory with RPM's, used only for building patterns
    // and not present on AddOn
    "required_rpm_path"	: "",
    // map of patterns for current product
    "patterns"		: $[],
    // description of packages (initially generated by create_package_descr
    "packages_descr"	: $[],
    // the contents of products files
    "products_files"	: [],
    // the contents of media files
    "media_files"	: [],
    // the contents of patches files
    "patches_files"	: [],
    // the contents of info.txt file
    "info"		: "",
    // content of readme files
    "readme_files"	: $[
	"README"	: ""
    ],
    // content of license files (in media.1 dir)
    "license_files"	: $[
        "license"	: ""
    ],
    "copying_files"	: $[
	"COPYING"	: ""
    ],
    "copyright_files"	: $[
        "COPYRIGHT"	: ""
    ],
    // the contents of EXTRA_PROV file
    "extra_prov"	: "",
    // path to the file with EXTRA_PROV data
    "extra_prov_file"	: "",
    // the contents of nextmedia file
    "nextmedia"		: "",
    // paths with packages to be archived in y2update.tgz
    "y2update_packages"	: [],
    // path with y2update.tgz (alternative to y2update_packages)
    "y2update_path"	: "",
    // path to file with installation workflow (installation.xml)
    "workflow_path"	: "",
    // if iso image should be created from the final Add-On
    "iso"		: false,
    // where the iso image should be put
    "iso_path"		: "",
    // name of the iso image file
    "iso_name"		: "",
    // also sign all rpm's (see bug #287447)
    "resign_packages"	: false,
    // current GPG key
    "gpg_key"		: "",
];

// skeleton for current_product map (with keys and default values)
map current_product_skel	= current_product;

global integer selected_product	= -1;

/**
 * variables from content file + their description
 */
global list<map> content	= [];

global list<string> allowed_archs = [ "ppc", "ppc64", "ia64", "x86_64", "i686", "i586", "i486", "i386","noarch"];


map<string,map> content_descr	= $[
    "PRODUCT"	: $[
	    "key"	: "PRODUCT",
	    // label of content file key
	    "label"	: _("Product name"),
	    // help text for content file 'PRODUCT' key
	    "help"	: _("Name of the add-on product"),
	    "mandatory"	: true,
    ],
    "VERSION"	: $[
	    "key"       : "VERSION",
	    // label of content file 'VERSION' key
	    "label"	: _("Product version and release"),
	    // help text for content file 'VERSION' key
	    "help"	: _("Product version and release as in RPM <tt>major.minor-release</tt>."),
	    "value"	: "1",
	    "mandatory"	: true,
    ],
    "DISTPRODUCT"	: $[
	    "key"	: "DISTPRODUCT",
	    // label of content file key
	    "label"	: _("Distribution ID"),
	    // help text for content file 'DISTPRODUCT' key
	    "help"	: _("Distribution ID (vendor specific). The value of the keyword must not contain spaces. Only letters, numbers, and the characters \".~_-\" are allowed."),
	    "mandatory"	: true,
    ],
    "DISTVERSION"	: $[
	    "key"	: "DISTVERSION",
	    // label of content file key
	    "label"	: _("Distribution version"),
	    // help text for content file 'DISTVERSION' key
	    "help"	: _("Distribution version (vendor specific)."),
	    "value"	: "1",
	    "mandatory"	: true,
    ],
    "VENDOR"		: $[
	    "key"	: "VENDOR",
	    // label of content file key
	    "label"	: _("Vendor name"),
	    // help text for content file 'VENDOR' key
	    "help"	: _("Vendor name (free form)."),
	    "mandatory"	: true,
    ],
    "REQUIRES"		: $[
	    "key"	: "REQUIRES",
	    // label of content file key
	    "label"	: _("Resolvables that must be installed"),
	    // help text for content file 'REQUIRES' key
	    "help"	: _("<p>Resolvables that must be installed on the system to meet the needs of this product.</p>
<p>This is a space-separated list of names or <tt>kind:name</tt> pairs optionally followed by version constraints. Just a name denotes a dependency to a package, such as <tt>sles-release</tt> or <tt>sles-release-10</tt>. The kind can be package, pattern, or product, such as <tt>pattern:basesystem</tt>.</p>"),
	    "mandatory"	: true,
//TODO editor...
    ],
    "DESCRDIR"		: $[
	    "key"	: "DESCRDIR",
	    // label of content file key
	    "label"	: _("Package description directory"),
	    "value"	: "suse/setup/descr",
	    // help text for content file 'DESCRDIR' key
	    "help"	: _("Package description directory (relative to product directory)."),
	    "mandatory"	: true,
    ],
    "DATADIR"		: $[
	    "key"	: "DATADIR",
	    // label of content file key
	    "label"	: _("Package data directory"),
	    // help text for content file 'DATADIR' key
	    "help"	: _("Package data directory (relative to product directory)."),
	    "value"	: "suse",
	    "mandatory"	: true,
    ],
    "DEFAULTBASE"	: $[
	    "key"	: "DEFAULTBASE",
	    // label of content file key
	    "label"	: _("Minimum architecture base supported"),
	    // help text for content file 'DEFAULTBASE' key
	    "help"	: _("Minimum architecture base supported by this product. The default is the base architecture if no matching <b>ARCH.base</b> is found."),
	    "mandatory"	: true,
	    "type"	: "combo",
	    "allowed_values"	: allowed_archs,
    ],
    "PREREQUIRES"	: $[
	    "key"	: "PREREQUIRES",
	    // labeliption of content file PREREQUIRES key
	    "label"	: _("Resolvables needed before installation"),
	    // help text for content file 'PREREQUIRES' key
	    "help"	: _("Resolvables that must be installed on the system before the installation of this product. The syntax is the same as for <b>REQUIRES</b>."),
    ],
    "LABEL"		: $[
	    "key"	: "LABEL",
	    // label of content file key
	    "label"	: _("Label"),
	    // help text for content file '' key
	    "help"	: _("UTF-8 encoded label. Default label if <b>LINGUAS</b> is omitted or no default language can be determined."),
    ],
    "PROVIDES"		: $[
	    "key"	: "PROVIDES",
	    // label of content file PROVIDES key
	    "label"	: _("Resolvables provided"),
	    // help text for content file 'PROVIDES' key
	    "help"	: _("Capabilities this product provides. They can be used to match <b>REQUIRES</b> from others. Every resolvable has a provides by default- its own name and edition. For example, package <i>bar-1.42-1</i> provides the capability <tt>bar = 1.42-1</tt>."),
    ],
    "CONFLICTS"		: $[
	    "key"	: "CONFLICTS",
	    // label of content file 'CONFLICTS' key
	    "label"	: _("Conflicting resolvables"),
	    // help text for content file 'CONFLICTS' key
	    "help"	: _("This resolvable cannot be installed if the specified resolvable or one that provides the capability is installed."),
    ],
    "OBSOLETES"		: $[
	    "key"	: "OBSOLETES",
	    // label of content file 'OBSOLETES' key
	    "label"	: _("Resolvables made obsolete"),
	    // help text for content file 'OBSOLETES' key
	    "help"	: _("When this resolvable is installed, it uninstalls any other resolvable with a name matching this keyword."),
    ],
    "RECOMMENDS"	: $[
	    "key"	: "RECOMMENDS",
	    // label of content file 'RECOMMENDS' key
	    "label"	: _("Recommended resolvables"),
	    // help text for content file 'RECOMMENDS' key
	    "help"	: _("A weak version of <b>REQUIRES</b>. An attempt is made to fulfill <b>RECOMMENDS</b>, but they are silently ignored if no match is possible."),
    ],
    "SUGGESTS"		: $[
	    "key"	: "SUGGESTS",
	    // label of content file 'SUGGESTS' key
	    "label"	: _("Suggested resolvables"),
	    // help text for content file 'SUGGESTS' key
	    "help"	: _("These are just hints for an application and not handled during dependency resolution."),
    ],
    "SUPPLEMENTS"	: $[
	    "key"	: "SUPPLEMENTS",
	    // label of content file 'SUPPLEMENTS' key
	    "label"	: _("Supplemented resolvables"),
	    // help text for content file 'SUPPLEMENTS' key
	    "help"	: _("A reverse <b>RECOMMENDS</b>. This product is installed if the specified capability is provided by an installed resolvable. The dependency resolver installs it. Uninstalling it is silently accepted."),
    ],
    "ENHANCES"		: $[
	    "key"	: "ENHANCES",
	    // label of content file 'ENHANCES' key
	    "label"	: _("Enhanced resolvables"),
	    // help text for content file 'ENHANCES' key
	    "help"	: _("A reverse <b>SUGGESTS</b>. This product can be installed if this capability is provided by an installed resolvable. It is just a hint for an application. For example, <i>SuSEplugger</i> can suggest packages for installation if specific hardware is found."),
    ],
    "LINGUAS"		: $[
	    "key"	: "LINGUAS",
	    // label of content file 'LINGUAS' key
	    "label"	: _("Languages"),
	    // help text for content file 'LINGUAS' key
	    "help"	: _("ISO language code or language code_country code."),
// TODO editor
    ],
    "LANGUAGE"		: $[
	    "key"	: "LANGUAGE",
	    // label of content file 'LANGUAGE' key
	    "label"	: _("Default language"),
	    // help text for content file 'LANGUAGE' key
	    "help"	: _("Default language code."),
	    "type"	: "combo",
	    "allowed_values"	: nil,
    ],
    "RELNOTESURL"	: $[
	    "key"	: "RELNOTESURL",
	    // label of content file 'RELNOTESURL' key
	    "label"	: _("Release notes URL"),
	    // help text for content file 'RELNOTESURL' key
	    "help"	: _("URL from which to fetch release notes."),
    ],
    "FLAGS"		: $[
	    "key"	: "FLAGS",
	    // label of content file 'FLAGS' key
	    "label"	: _("Flags"),
	    // help text for content file 'FLAGS' key
	    "help"	: _("Product-specific capabilities."),
    ],
    "UPDATEURLS"	: $[
	    "key"	: "UPDATEURLS",
	    // label of content file 'UPDATEURLS' key
	    "label"	: _("Update URL"),
	    // help text for content file 'UPDATEURLS' key
	    "help"	: _("URL of the update source."),
    ],
    "PATTERNS"		: $[
	    "key"	: "PATTERNS",
	    // label of content file 'PATTERNS' key
	    "label"	: _("Preselected patterns"),
	    // help text for content file 'PATTERNS' key
	    "help"	: _("List of patterns preselected by the product."),
    ],
    "SHORTLABEL"	: $[
	    "key"	: "SHORTLABEL",
	    // label of content file 'SHORTLABEL' key
	    "label"	: _("Short label"),
    ],
];

// skeletons for special keys in content file
global map content_specials	= $[

    "LABEL"	: $[
	    // label of content file LABEL.lang key
	    "label"	: _("Language-specific label"),
	    // help text for content file 'LABEL.lang' key
	    "help"	: _("UTF-8-encoded <b>LABEL</b>. <tt>lang</tt> has the same syntax as the <b>LINGUAS</b> values. For each language in <b>LINGUAS</b>, a matching <b>LABEL.lang</b> is expected."),
	    "helplabel"	: "LABEL.lang",
    ],
    "ARCH"	: $[
	    // label of content file ARCH.base key
	    "label"	: _("Allowed architectures"),
	    // help text for content file 'ARCH.base' key
	    "help"	: _("Space-separated list of allowed architectures for <tt>base</tt>."),
	    "helplabel"	: "ARCH.base",
	    "mandatory"	: true
    ],
];


// desctiption of pattern keys
global map<string,map> pattern_descr	= $[
    "name"	: $[
	"internal"	: true,
    ],
    "version"	: $[
	"label"		: _("Version"),
	"internal"	: true,
	"adapt_name"	: true,
	"defval"	: "1.0",
    ],
    "release"	: $[
	"label"		: _("Release"),
	"internal"	: true,
	"adapt_name"	: true,
	"defval"	: "1",
    ],
    "arch"	: $[
	"label"		: _("Architecture"),
	"internal"	: true,
	"type"		: "combo",
	"allowed_values": allowed_archs,
	"adapt_name"	: true,
	"defval"	: "noarch",
    ],
    "Pat"	: $[
	"single_line"	: true,
    ],
    "Ver"	: $[
	"defval"	: "5.0",
	"single_line"	: true,
    ],
    "Sum"	: $[
	"label"		: _("Summary"),
	// help text for 'Sum' pattern key
	"help"		: _("One line label in the default language"),
	// help text for 'Sum.lang' pattern key
	"lang_help"	: _("One line language-specific label."),
	"single_line"	: true,
    ],
    "Des"	: $[
	// label for 'Des' pattern key
	"label"		: _("Description"),
	"type"		: "multiline",
	// help text for 'Des' pattern key
	"help"		:_("Multiple line description in the default language"),
	// help text for 'Des.lang' pattern key
	"lang_help"	:_("Multiple line description, language-specific.")
    ],
    "Cat"	: $[
	// label for 'Cat' pattern key
	"label"		: _("Category"),
	// help text for 'Cat' pattern key
	"help"		: _("One line category in the default language used to group patterns. Categories are intended for the user and can be specified freely."),
	// help text for 'Cat.lang' pattern key
	"lang_help"	: _("Language-specific version of the category."),
	"single_line"	: true,
    ],
    "Vis"	: $[
	// label for 'Vis' pattern key
	"label"		: _("Visibility"),
	// help text for 'Vis' pattern key
	"help"		: _("Set whether the pattern should be visible in the user interface."),
	"type"		: "boolean",
	"defval"	: true,
	"single_line"	: true,
    ],
    "Prq"	: $[
	// label for 'Prq' pattern key
	"label"		: _("Packages"),
	// help text for 'Prq' pattern key
	"help"		: _("List of packages to install."),
	"type"		: "package-list",
	"defval"	: [],
    ],
    "Prc"	: $[
	// label for 'Prc' pattern key
	"label"		: _("Recommended packages"),
	// help text for 'Prc' pattern key
	"help"		: _("These packages are installed by default but can be removed without complaint."),
	"type"		: "package-list",
	"defval"	: [],
    ],
    "Psg"	: $[
	// label for 'Prs' pattern key
	"label"		: _("Suggested packages"),
	// help text for 'Prs' pattern key
	"help"		: _("These are just hints for an application and not handled during dependency resolution."),
	"type"		: "package-list",
	"defval"	: [],
    ],
    "Ico"	: $[
	// label for 'Ico' pattern key
	"label"		: _("Icon filename"),
	// help text for 'Ico' pattern key
	"help"		: _("If unspecified, the pattern name is used 
 instead (with blanks in the name replaced by underscores). If the filename does not include a .png or .jpg extension, .png is appended. If no path is specified, icons are searched for in the theme icon path (first /usr/share/YaST2/theme/current/icons/32x32/apps/ then /usr/share/YaST2/theme/current/icons/48x48/apps/). Absolute and relative paths (to the theme path /usr/share/YaST2/theme/current/) are allowed."),
	"type"		: "file-name",
	"defval"	: "",
	"single_line"	: true,
    ],
    "Ord"	: $[
	// label for 'Ord' pattern key
	"label"		: _("Pattern Order"),
	// help text for 'Ord' pattern key
	"help"		: _("This three-digit integer value defines the order of the pattern when listing multiple patterns in the user interface."),
	"defval"	: "",
	"single_line"	: true,
	"type"		: "integer",
	"range"		: [ 100, 9999 ],
    ],
    "Req"	: $[
	// label for 'Req' pattern key
	"label"		: _("Required patterns"),
	// help text for 'Req' pattern key
	"help"		: _("Patterns that need to be installed together with this pattern."),
	"defval"	: "",
	"type"		: "pattern-list",
    ],
    "Prv"	: $[
	// label for 'Prv' pattern key
	"label"		: _("Provided patterns"),
	// help text for 'Prv' pattern key
	"help"		: _("Capabilities this pattern provides. They can be used to match <b>REQUIRES</b> from others. Every resolvable has a provide by default--its own name and edition. For example, package <i>bar-1.42-1</i> provides the capability <tt>bar = 1.42-1</tt>."),
	"defval"	: "",
	"type"		: "pattern-list",
    ],
    "Con"	: $[
	// label for 'Con' pattern key
	"label"		: _("Conflicting patterns"),
	// help text for 'Con' pattern key
	"help"		: _("This pattern cannot be installed if the specified resolvable or one that provides the capability is installed."),
	"defval"	: "",
	"type"		: "pattern-list",
    ],
    "Obs"	: $[
	// label for 'Obs' pattern key
	"label"		: _("Patterns made obsolete"),
	// help text for 'Obs' pattern key
	"help"		: _("When this pattern is installed, it uninstalls any 
other patterns marked as obsolete here."),
	"defval"	: "",
	"type"		: "pattern-list",
    ],
    "Rec"	: $[
	// label for 'Rec' pattern key
	"label"		: _("Recommended patterns"),
	// help text for 'Rec' pattern key
	"help"		: _("A weak version of REQUIRES. If recommended patterns cannot be installed, no error is shown."),
	"defval"	: "",
	"type"		: "pattern-list",
    ],
    "Sup"	: $[
	// label for 'Sup' pattern key
	"label"		: _("Supplemented patterns"),
	// help text for 'Sup' pattern key
	"help"		: _("A reverse <b>Rec</b>. This pattern is installed if the specified capability is provided by an installed resolvable. The dependency resolver installs it. Uninstalling it is silently accepted."),
	"defval"	: "",
	"type"		: "pattern-list",
    ],
    "Sug"	: $[
	// label for 'Sug' pattern key
	"label"		: _("Suggested patterns"),
	// help text for 'Sug' pattern key
	"help"		: _("These are just hints for an application and not handled during dependency resolution."),
	"defval"	: "",
	"type"		: "pattern-list",
    ],
    "Fre"	: $[
	// label for 'Fre' pattern key
	"label"		: _("Freshen"),
	// help text for 'Fre' pattern key
	"help"		: _("The current pattern is only considered for installation if the pattern specified here is installed."),
	"defval"	: "",
	"type"		: "pattern-list",
    ],
    // TODO during editing, remove from Prc and Prs packages contained in Prq
    // TODO add some key for sorting, so output file is readable


    // FIXME new keys, add labels after 11.0
    "Ext"	: $[
	// label for 'Ext' pattern key
	"label"		: _("Extends"),
	"defval"	: "",
	"type"		: "pattern-list",
    ],
    "Inc"	: $[
	// label for 'Inc' pattern key
	"label"		: _("Includes"),
	"defval"	: "",
	"type"		: "pattern-list",
    ],
    "Enh"	: $[
	// label for 'Exnh pattern key
	"label"		: _("Enhanced patterns"),
	"defval"	: "",
	"type"		: "pattern-list",
    ],
    "Pcn"	: $[
	// label for 'Pcn' pattern key
	"label"		: _("Conflicting packages"),
	"type"		: "package-list",
	"defval"	: [],
    ],
    "Pob"	: $[
	// label for 'Pob' pattern key
	"label"		: _("Obsoleted packages"),
	"type"		: "package-list",
	"defval"	: [],
    ],
    "Pfr"	: $[
	// label for 'Pfr' pattern key
	"label"		: _("Freshened packages"),
	"type"		: "package-list",
	"defval"	: [],
    ],
    "Psp"	: $[
	// label for 'Psp' pattern key
	"label"		: _("Supplemented packages"),
	"type"		: "package-list",
	"defval"	: [],
    ],
    "Pen"	: $[
	// label for 'Pen' pattern key
	"label"		: _("Enhanced packages"),
	"type"		: "package-list",
	"defval"	: [],
    ],
 ];

// description of keys in package description files
global map<string,map> description_descr	= $[
    "Pkg"	: $[
	// label for 'Pkg' key
	"label"		: _("Package"),
    ],
    "Des"	: $[
	// label for 'Des' key
	"label"		: _("Description"),
	// help text for 'Des' key
	"help"		: _("Multiple line package description."),
	"type"		: "multiline",
	"defval"	: "-",
    ],
    "Sum"	: $[
	// label for 'Sum' key
	"label"		: _("Summary"),
	// help text for 'Sum' key
	"help"		: _("The package summary (label), a one line description of the package."),
	"single_line"	: true,
	"defval"	: "-",
    ],
    "Ins"	: $[
	// label for 'Ins' key
	"label"		: _("Installation Notification"),
	// help text for 'Ins' key
	"help"		: _("An informal message shown to the user if the package is selected, such as a test version warning or a commercial license."),
	"type"		: "multiline",
    ],
    "Del"	: $[
	// label for 'Del' key
	"label"		: _("Deletion Notification"),
	// help text for 'Del' key
	"help"		: _("An informal message shown to the user if the package is selected for deletion, such as a warning that the system is unusable without the package."),
	"type"		: "multiline",
    ],
    "Eul"	: $[
	// label for 'Eul' key
	"label"		: _("EULA"),
	// help text for 'Eul' key
	"help"		: _("Text of the EULA. This text is displayed before the package installation. If the user does not accept the EULA, the package is not installed."),
	"type"		: "multiline",
    ],
];

// script used for signing rpm's
string expect_script =
"#!/usr/bin/expect --
exp_internal 0

set stat 0
foreach rpm $argv {
    spawn -noecho rpm --delsign $rpm
    expect {
	eof {}
    }
    spawn -noecho rpm --define \"_signature gpg\" --define \"_gpg_name %1\" --define \"_gpgbin /usr/bin/gpg\" --resign $rpm
    expect \"pass phrase:\" {send \"%2\r\"}
    expect {
	\"is good.\" {send \"\n\"}
	eof {}
    }
    wait
    spawn -noecho rpm --define \"_signature gpg\" --define \"_gpg_name %1\" --define \"_gpgbin /usr/bin/gpg\" --checksig $rpm
    expect {
	-re \": .*(gpg|pgp).*OK\" {continue;}
	eof      {set stat 1;}
    }
}
exit $stat";

// just key:value mapping based on content list
global map<string,string> content_map	= $[];

/**
 * if we have 'source add-on' to base the new one on
 */
global boolean clone	= false;

/**
 * path to directory with existing product (which is being cloned)
 */
global string import_path	= "";

/**
 * if the descriptions of packages should be generated
 * (false have only sense when cloning where they could be read from
 * description files of cloned product)
 */
global boolean generate_descriptions = false;

/**
 * if final Add-On should be bootable (feature not implemented)
 */
global boolean bootable	= false;

// tmp directory
string tmpdir	= "";

// full paths to media directories (media.n)
list<string> full_media_paths	= [];

// architecture specific directory names of target product
list<string> arch_directories = [];

// full path to descr directory
string full_descr_path	= "";

// full path to data directory
string full_data_path = "";

// current GPG key
//global string gpg_key	= "";

// passphrases to unlock secret key (mapping GPG key:pass)
global map passphrases	= $[];

global list<string> gpg_keys	= [];

// packages from current AddOn available for the pattern
global map<string,list> available_packages = $[];

// mapping of package name to full file name
global map<string,map> package2filename = $[];

// mapping of source package name to full file name
global map<string,map> srcpackage2filename	= $[];

// if we want only to sign existing product (and possibly create iso of it)
global boolean only_sign_product		= false;

// if pattern files should be compressed
global boolean compress_patterns		= false;

// if pattern definitions should be merged into one file TODO
global boolean merge_patterns			= false;

// if package description files should be compressed
global boolean compress_package_descriptions	= false;

/**
 * Data was modified?
 */
global boolean modified = false;

/**
 * Data was modified?
 * @return true if modified
 */
global boolean Modified() {
    y2debug("modified=%1",modified);
    return modified;
}

boolean gzip_is_installed	= nil;

boolean gzip_installed () {
    if (gzip_is_installed == nil)
	gzip_is_installed = Package::Installed ("gzip");
    return gzip_is_installed;
}

map lang_codes = $[
    "languages"		: nil,
    "with_country"	: nil,
];

/**
 * Take list of content-file data and update global content_map.
 * If argument is empty, global 'content' list is used as an input.
 */
global map<string,string> UpdateContentMap (list<map> content_list) {

    if (content_list == nil || content_list == [])
	content_list	= content;
    foreach (map entry, content_list, {
	if (entry["value"]:"" != "")
	    content_map[entry["key"]:""] = entry["value"]:"";
    });
    return content_map;
}


// return list of language codes, optionally together with country code
global list<string> GetLangCodes (boolean country) {

    string key	= country ? "with_country" : "languages";
    string cut	= country ? "cut -f 1 -d . | cut -f 1 -d @" : "cut -f 1 -d _";
    if (lang_codes[key]:nil == nil)
    {
	map out = (map) SCR::Execute (.target.bash_output, "locale -a | " + cut,
	    $[ "LANG" : "C"]);
	lang_codes[key] =
	    filter (string l, toset (splitstring (out["stdout"]:"", "\n")), {
		return (l != "" && l != "C" && l != "POSIX");
	    });
    }
    return lang_codes[key]:[];
}

// if file is true, it creates the file name for the pattern, otherwise
// the Pat value
global string CreatePatternFullName (map pattern, boolean file) {
    return sformat ("%1%5%2%5%3%6%4%7",
	pattern["name"]:"",
        pattern["version"]:"",
        pattern["release"]:"",
        pattern["arch"]:"",
	file ? "-" : " ",
	file ? "." : " ",
	file ? ".pat" : ""
    );
}

// read the list of available secret keys
list<string> read_secret_keys () {

    map out = (map) SCR::Execute (.target.bash_output, "gpg --list-secret-keys|grep '^sec'|sed -e 's/.*\\///;s/ .*//g;'");
    return filter (string k, splitstring(out["stdout"]:"", "\n"),``(k!=""));
}


/**
 * Generate the key pair
 */
global string GenerateGPGKey (map<string,string> data) {

    string data_cont	= sformat ("Key-Type: %1\n", data["Key-Type"]:"");
    data = remove (data, "Key-Type");
    foreach (string key, string val, data, {
	if (val != "")
	    data_cont	= data_cont + sformat ("%1: %2\n", key, val);
    });

    // save the needed data to file
    string data_path	= tmpdir + "/gen-key-data";
    SCR::Write (.target.string, data_path, data_cont);

    map out	= (map) SCR::Execute (.target.bash_output,
	"gpg --batch --gen-key " + data_path);
    if (out["exit"]:0 != 0)
    {
	y2warning ("error calling gpg: %1", out);
	return "";
    }

    SCR::Execute (.target.remove, data_path);

    gpg_keys	= read_secret_keys ();
    return gpg_keys[size (gpg_keys) - 1]:"";
}

/**
 * Initialize the settings for add-on-creator
 * @return true on success
 */
global boolean Read() {

    if (!PackageSystem::CheckAndInstallPackagesInteractive (["inst-source-utils"]))
	return false;

    gpg_keys	= read_secret_keys ();

    map out = (map) SCR::Execute (.target.bash_output, "/usr/bin/id --user");
    if (out["stdout"]:"" != "0\n" && out["stdout"]:"" != "")
    {
	// TODO use getenv builtin when it is available
	out	= (map) SCR::Execute (.target.bash_output, "echo $HOME");
	string home	= deletechars (out["stdout"]:"", "\n");
	if (home != "" && home != nil)
	    add_on_products_file	= home + "/add_on_products.ycp";
    }

    // Read the info of configured AddOns
    if (FileUtils::Exists (add_on_products_file))
    {
	list<map> all_products	= (list<map>)
	    SCR::Read (.target.ycp, add_on_products_file);
	if (all_products != nil)
	{
	    add_on_products	= maplist (map product, all_products, {
		return product;
	    });
	}
    }
    else
    {
	current_product["gpg_key"]	= gpg_keys[0]:"";
    }

    // fill uninitialized values in content descriptions
    integer i	= 0;

    foreach (string key, map entry, content_descr, {
	if (entry["allowed_values"]:nil == nil)
	{
	    // TODO add a handlers for filling the values
	    if (key == "LANGUAGE")
		content_descr[key,"allowed_values"] = GetLangCodes (true);
	    else
		content_descr[key,"allowed_values"] = [];
	}
	if (key == "DEFAULTBASE")
	    content_descr[key,"value"]	= Arch::architecture ();
	string defval = (string)SCR::Read (add(.sysconfig.add-on-creator, key));
	if (defval != nil && defval != "")
	{
	    y2milestone ("using default value for %1: %2", key, defval);
	    content_descr[key,"value"]	= defval;
	}
	i	= i + 1;
    });

    tmpdir	= Directory::tmpdir;

    if (SCR::Read (.sysconfig.add-on-creator.COMPRESS_PATTERNS) == "yes")
	compress_patterns	= true;

    if (SCR::Read (.sysconfig.add-on-creator.COMPRESS_PACKAGE_DESCRIPTIONS)
	== "yes")
	compress_package_descriptions	= true;

    return true;
}

// proposal for ARCH.* values (of content file)
// FIXME this won't work for other architectures...
global string ValueForArchitecture (string arch_dir) {

    string val = "";
    foreach (string arch, allowed_archs, {
	if (arch == arch_dir)
	    val	= arch;
	else if (val != "")
	    val = val + " " + arch;
    });
    return val;
}

// read the content file given by file name
global list<map> ReadContentFile (string file_path) {

    list<map> ret	= [];

    y2milestone ("Importing content file '%1'", file_path);

    SCR::RegisterAgent (.content, `ag_ini (`IniAgent (file_path,
	$[
	    "options" : ["global_values", "flat"],
	    "comments" : [ "^#.*", "^[ \t]*$", ],
	    "params" : [ $[
		"match" : [
		    "^[ \t]*([a-zA-Z0-9_\.]+)[ \t]+(.*[^ \t]|)[ \t]*$",
		    "%s %s",
		]
	    ] ]
	]
    )));

    list<string> keys	= (list<string>) SCR::Dir (.content);
    foreach (string key, keys, {
	string val = (string) SCR::Read (add (.content, key));
	if (val == nil) return;
	map entry	= content_descr[key]:$[];
	if (entry == $[] && issubstring (key, "."))
	{
	    entry	=
		content_specials[substring (key,0,findfirstof (key,"."))]:$[];
	}
	if (entry != $[])
	{
	    entry["key"]	= key;
	    entry["value"]	= val;
	    ret	= add (ret, entry);
	    content_map[key]	= val;
	}
    });
    SCR::UnregisterAgent (.content);

    // + fill the rest
    foreach (string key, map entry, content_descr, {
	if (!contains (keys, key))
	    ret = add (ret, entry);
    });

    return ret;
}

/**
 * Take a path to compressed file as argument and return path to uncompressed one\
 */
string uncompress_file (string file_path) {

    string ret	= file_path;
    if (substring (file_path, size (file_path) - 3, 3) == ".gz" &&
	gzip_installed ())
    {
	list full	= splitstring (file_path, "/");
	string file	= full[size (full) - 1]:"";
	if (!FileUtils::Exists (tmpdir + "/" + file))
	    SCR::Execute (.target.bash, sformat ("cp %1 %2/", file_path, tmpdir));
	map o = (map)SCR::Execute (.target.bash_output, sformat ("cd %1; gunzip %2", tmpdir, file));
	if (o["exit"]:1 == 0)
	    ret = tmpdir + "/" + substring (file, 0, size (file) - 3);
	else
	    y2warning ("gunzip failed with %1 (%2)", o["exit"]:0, o["stderr"]:"");
    }
    return ret;
}

// read the pattern given by file name (obsolete, use ReadPatternsFile instead)
global map ReadPatternFile (string file_path) {

    y2milestone ("Importing pattern '%1'", file_path);
    file_path	= uncompress_file (file_path);

    map ret	= $[];
    map pt	= (map) SCR::Read (.pattern, file_path);

    foreach (string key, any val, (map<string,any>) pt, {
	if (pattern_descr[key,"type"]:"" == "package-list")
	{
	    ret[key]	= splitstring (sformat ("%1", val), "\n");
	    // make the packages included in imported pattern available for UI
	    available_packages["ZZZ_imported"] = union (
		available_packages["ZZZ_imported"]:[], ret[key]:[]);
	}
	else
	    ret[key]	= val;
    });
    foreach (string key, map descr, pattern_descr, {
	if (!haskey (ret, key) && !descr["internal"]:false)
	{
	    y2debug ("adding empty key '%1'...", key);
	    // do not add default values - maybe imported pattern
	    // ignored them intentionally
	    ret[key]	= "";
	}
    });
    return ret;
}

/**
 * read all the patterns defined in given file
 * @return list of pattern maps
 */
global list<map> ReadPatternsFile (string file_path) {

    y2milestone ("Importing pattern '%1'", file_path);
    file_path	= uncompress_file (file_path);

    list<map> retlist	= [];
    list<map> pts	= (list<map>) SCR::Read (.pattern.list, file_path);

    foreach (map pt, pts, {
	map ret	= $[];
	foreach (string key, any val, (map<string,any>) pt, {
	    if (pattern_descr[key,"type"]:"" == "package-list")
	    {
		ret[key]	= splitstring (sformat ("%1", val), "\n");
		// make the packages included in pattern available for UI
		available_packages["ZZZ_imported"] = union (
		    available_packages["ZZZ_imported"]:[], ret[key]:[]);
	    }
	    else
		ret[key]	= val;
	});
	// add empty values for keys not present in imported pattern
	foreach (string key, map descr, pattern_descr, {
	    if (!haskey (ret, key) && !descr["internal"]:false)
	    {
		y2debug ("adding empty key '%1'...", key);
		// do not add default values - maybe imported pattern
		// ignored them intentionally
		ret[key]	= "";
	    }
	});
	if (ret != $[])
	    retlist	= add (retlist, ret);
    });
    return retlist;
}

// read the package description (package.lang) file
global map ReadPackagesFile (string file_path) {

    y2milestone ("Importing package description '%1'", file_path);

    return PackagesDescr::Read (uncompress_file (file_path));
}

/**
 * import the data from existing add-on
 * @param path to existing addon directory
 */
global boolean ImportExistingProduct (string dir_path) {

    content	= ReadContentFile (dir_path + "/content");

    current_product["rpm_path"]	=
	sformat("%1/%2", dir_path, content_map["DATADIR"]:"");

    // - read patterns
    string descr_path = sformat ("%1/%2", dir_path, content_map["DESCRDIR"]:"");

    map out = (map) SCR::Execute (.target.bash_output,
	sformat ("ls -A1 %1/*.pat %1/*.pat.gz 2>/dev/null", descr_path));
    map patterns	= $[];
    foreach (string f, splitstring(out["stdout"]:"", "\n"), {
	if (f == "") return;
	foreach (map pat, ReadPatternsFile (f), {
	    if (pat != $[])
	    {
		list<string> pt	= splitstring (pat["Pat"]:"", " ");
		string name	= pt[0]:"";
		if (name != "")
		{
		    pat["name"]		= name;
		    pat["version"]	= pt[1]:"";
		    pat["release"]	= pt[2]:"";
		    pat["arch"]		= pt[3]:"";
		    patterns[name]	= pat;
		}
	    }
	});
    });
    current_product["patterns"]	= patterns;

    if (!generate_descriptions)
    {
	SCR::Execute (.target.bash, sformat("/bin/rm -f %1/packages*", tmpdir));
	// save packages* files to tmpdir, they will be imported later
	SCR::Execute (.target.bash,
	    sformat ("/bin/cp %1/packages* %2", descr_path, tmpdir));
    }
    string extra	= descr_path + "/EXTRA_PROV";
    if (FileUtils::Exists (extra))
    {
	string cont     = (string) SCR::Read (.target.string, extra);
	if (cont != nil)
	{
	    current_product["extra_prov"]	= cont;
	    current_product["extra_prov_file"]	= extra;
	}
    }

    // read README
    foreach (string readme, ["README", "README.DOS", "LIESMICH","LIESMICH.DOS"],
    {
	string readme_path	= dir_path + "/" + readme;
	if (FileUtils::Exists (readme_path))
	{
	    y2milestone ("Importing readme file '%1'", readme_path);
	    string cont	= (string) SCR::Read(.target.string, readme_path);
	    if (cont != nil)
		current_product["readme_files", readme]	= cont;
	}
    });

    // read the license files
    string license_path	= dir_path + "/media.1/license.zip";
    out	= $[];
    // license.zip is obsolete
    if (FileUtils::Exists (license_path))
    {
	SCR::Execute (.target.bash_output,
	    sformat ("/usr/bin/unzip -o %1 -d %2", license_path, tmpdir));
	out = (map) SCR::Execute (.target.bash_output,
	    sformat ("ls -A1 %1/license*.txt 2>/dev/null", tmpdir));
    }
    else if (FileUtils::Exists (dir_path + "/license.tar.gz"))
    {
	SCR::Execute (.target.bash_output,
	    sformat ("/bin/tar -zxf %1/license.tar.gz -C %2", dir_path,tmpdir));
	out = (map) SCR::Execute (.target.bash_output,
	    sformat ("ls -A1 %1/license*.txt 2>/dev/null", tmpdir));
    }
    else if (FileUtils::IsDirectory (dir_path + "/media.1/license") == true)
    {
	out = (map) SCR::Execute (.target.bash_output,
	    sformat ("ls -A1 %1/media.1/license/license*.txt 2>/dev/null",
	    dir_path));
    }
    // extract license.txt from EULA.txt
    // (no other need to read EULA, it should be just license.txt + packages)
    else if (FileUtils::Exists (dir_path + "/EULA.txt"))
    {
	SCR::Execute (.target.bash,
	    sformat ("/bin/cp %1/EULA.txt %2/license.txt", dir_path, tmpdir));
	out = (map) SCR::Execute (.target.bash_output,
	    sformat ("ls -A1 %1/license*.txt 2>/dev/null", tmpdir));
    }
    if (out != $[])
    {
	foreach (string f, splitstring(out["stdout"]:"", "\n"), {
	    if (f == "") return;
	    string name	= substring (f, findlastof (f, "/") + 1);
	    if (issubstring (name, ".txt"))
		name	= regexpsub (name, "^(.*)\.txt$", "\\1");
	    y2milestone ("Importing license file '%1'", f);
	    string cont	= (string) SCR::Read (.target.string, f);
	    if (cont != nil)
		current_product["license_files", name]	= cont;
	});
    }

    out = (map) SCR::Execute (.target.bash_output,
	sformat ("ls -A1 %1/COPYING* 2>/dev/null", dir_path));
    foreach (string f, splitstring(out["stdout"]:"", "\n"), {
	if (f == "") return;
	string name	= substring (f, findlastof (f, "/") + 1);
	y2milestone ("Importing COPYING file '%1'", f);
	string cont	= (string) SCR::Read (.target.string, f);
	if (cont != nil)
	    current_product["copying_files",name] = cont;
    });

    out = (map) SCR::Execute (.target.bash_output,
	sformat ("ls -A1 %1/COPYRIGHT* 2>/dev/null", dir_path));
    foreach (string f, splitstring(out["stdout"]:"", "\n"), {
	if (f == "") return;
	string name	= substring (f, findlastof (f, "/") + 1);
	y2milestone ("Importing COPYRIGHT file '%1'", f);
	string cont	= (string) SCR::Read (.target.string, f);
	if (cont != nil)
	    current_product["copyright_files",name]	= cont;
    });

    // FIXME autorun

    // read the info.txt
    string info_path	= dir_path + "/media.1/info.txt";
    if (FileUtils::Exists (info_path))
    {
	string info	= (string) SCR::Read (.target.string, info_path);
	if (info == nil) info = "";
	current_product["info"]	= info;
    }

    // read the content of media.n dirs
    out = (map) SCR::Execute (.target.bash_output,
	sformat ("ls -A1 -d %1/media.* 2>/dev/null", dir_path));
    if (out["stdout"]:"" != "")
    {
	list<string> products_files	= [];
	list<string> media_files	= [];
	list<string> patches_files	= [];
	foreach (string d, splitstring(out["stdout"]:"", "\n"), {
	    if (d == "") return;
	    string products_path	= d + "/products";
	    if (FileUtils::Exists (products_path))
	    {
		y2milestone ("Importing products file '%1'", products_path);
		products_files	= add (products_files,
		    (string) SCR::Read (.target.string, products_path));
	    }
	    else products_files  = add (products_files, "");
	    string media_path	= d + "/media";
	    if (FileUtils::Exists (media_path))
	    {
		y2milestone ("Importing media file '%1'", media_path);
		media_files	= add (media_files,
		    (string) SCR::Read (.target.string, media_path));
	    }
	    else media_files	= add (media_files, "");
	    string patches_path	= d + "/patches";
	    if (FileUtils::Exists (patches_path))
	    {
		y2milestone ("Importing patches file '%1'", patches_path);
		patches_files	= add (patches_files,
		    (string) SCR::Read (.target.string, patches_path));
	    }
	    else patches_files	= add (patches_files, "");
	});
	current_product["products_files"]	= products_files;
	current_product["media_files"]		= media_files;
	current_product["patches_files"]	= patches_files;
    }

    string desc_path	= dir_path + "/installation.xml";
    if (FileUtils::Exists (desc_path))
    {
	current_product["workflow_path"]	= desc_path;
    }

    string workflow_packages_path	= dir_path + "/y2update.tgz";
    if (FileUtils::Exists (workflow_packages_path))
    {
	current_product["y2update_path"]	= workflow_packages_path;
    }

    return true;
}

/**
 * converts the output of find command (=possibly big string with each file on one line),
 * to the list of smaller strings (<128kB), each with space separated file names
 * @param stdout output of find command
 */
list<string> create_argument_lists (string stdout) {

    list<string> ret	= [];
    if (stdout == nil || stdout == "") return ret;
    // approximately maximum size of parameters list passed to rpm
    integer kbytes		= 120;
    // looks like pre-sorting helps to fasten rpm call
    list<string> found	= sort (splitstring (stdout, "\n"));
    if (size (stdout)/1024 <= kbytes)
	ret	= [ mergestring (found, " ") ];
    else
    {
	string line	= "";
	foreach (string file, found, {
	    line	= line + file + " ";
	    if (size (line) / 1024 > kbytes)
	    {
		ret	= add (ret, line);
		line	= "";
	    }
	});
	if (size (line) / 1024 <= kbytes)
	    ret	= add (ret, line);
    }
    return ret;
}

// this is used during the workflow, not in the write!
// TODO change name...
global void FillContentDefaults () {

    // AddOnCreator Build dialog caption
    string caption	= _("Generating Product Data");

    list stages	= [
	    // Progress stage
	    _("Find package directories"),
    ];
    list steps	= [
	    // Progress step
	    _("Looking for package directories..."),
    ];
    if (!clone)
    {
	stages	= union (stages, [
	    // Progress stage
	    _("Check package architectures"),
	    // Progress stage
	    _("Generate content file defaults"),
	]);
	steps	= union (steps, [
	    // Progress step
	    _("Checking package architectures..."),
	    // Progress step
	    _("Generating content file defaults..."),
	]);
    }
    stages	= union (stages, [
	    // Progress stage
	    _("Generate package descriptions"),
    ]);
    steps	= union (steps, [
	    // Progress step
	    _("Generate package descriptions"),
    ]);

    Progress::New (caption, " ", size (stages),
	(list<string>) stages, (list<string>) steps,
	// help text
	_("<b>Generating Data for Add-On</b><br>
Please wait...
"));

    Progress::NextStage();
    map<string,string> arch_map	= $[];
    string rpm_path	= current_product["rpm_path"]:"";

    // 1. set the values for ARCH.*
    string cmd	= sformat ("cd %1; find -maxdepth 1 -type d", rpm_path);
    map out	= $[];
    if (rpm_path != "")
	out	= (map) SCR::Execute (.target.bash_output, cmd);

    arch_directories	= [];
    foreach(string d, splitstring(out["stdout"]:"", "\n"), {
	list splitdir = splitstring (d, "/");
	string arch_dir	= splitdir[1]:"";
	if (contains (allowed_archs, arch_dir))
	{
	    arch_map["ARCH." + arch_dir ] = ValueForArchitecture (arch_dir);
	    arch_directories	= add (arch_directories, arch_dir);
	}
    });
    Progress::NextStage();

    if (!clone)
    {
	// 2. get the list of architectures from RPM's
	if (rpm_path != "")
	    out	= (map) SCR::Execute (.target.bash_output,
		sformat ("find %1 -name '*.rpm'", rpm_path));
	y2milestone ("asking the RPM's for ARCH and NAME...");
	foreach (string f, splitstring (out["stdout"]:"", "\n"), {
	    if (f == "") return;
	    out = (map) SCR::Execute (.target.bash_output,
	        sformat ("rpm -q -p %1 --qf \"%%{ARCH}\n%%{NAME}\n%%|SOURCERPM?{bin}:{src}|\"",f));
	    list lines  = splitstring (out["stdout"]:"", "\n");
	    string arch = lines[0]:"";
	    string name = lines[1]:"";
	    string sourcerpm	= lines[2]:"";
	    // 'arch' is directory where to put final package
	    if (sourcerpm == "src")
		arch	= "src";
	    if (name != "" && arch != "")
	    {
		available_packages[arch] = add (
		    available_packages[arch]:[], name);
		if (!haskey (package2filename, arch))
		    package2filename[arch]	= $[];
		if (!haskey (srcpackage2filename, arch))
		    srcpackage2filename[arch]	= $[];
		if (arch != "src")
		    package2filename[arch,name]	= f;
		else
		    srcpackage2filename[arch,name]      = f;
	    }
	});
	y2milestone ("... done");
	Progress::NextStage();

	// 3. add 'guessed' ARCH.base values to the content file
	if (content_map != $[] || arch_map != $[])
	{
	    content	= []; // new proposal
	    foreach (string key, map entry, content_descr, {
		if (content_map[key]:"" != "")
		    entry["value"]	= content_map[key]:"";
		content	= add (content, entry);
	    });
	    map arch_skel	= content_specials["ARCH"]:$[];
	    foreach (string key, string val, arch_map, {
		arch_skel["key"]	= key;
		arch_skel["value"]	= val;
		content = add (content, arch_skel);
	    });
	}
	string required_rpm_path = current_product["required_rpm_path"]:"";
	// 4. read the list of packages, not present on AddOn
	if (required_rpm_path != "" && required_rpm_path != rpm_path)
	{
	    out	= (map) SCR::Execute (.target.bash_output,
		sformat ("cd %1; find -name '*.rpm'", required_rpm_path));
	    y2milestone ("asking the RPM's for NAME...");
	    list<string> inputs		= create_argument_lists (out["stdout"]:"");
	    string output	= "";
	    foreach (string input, inputs, {
		string cmd	= sformat ("cd %1; rpm --qf \"%%{NAME}\n\" -qp %2",
		    required_rpm_path, input);
		out	= (map) SCR::Execute (.target.bash_output, cmd);
		output	= output + out["stdout"]:"" + "\n";
	    });
	    // remove empty strings and duplicates
	    available_packages["ZZZ_required"] = toset (filter (
		string name, splitstring (output, "\n"), ``(name != "")));
	    y2milestone ("... done");
	}
	Progress::NextStage();
    }
    if (rpm_path == "")
    {
	Progress::Finish ();
	return;
    }

    // generate tmp package descriptions...
    // TODO move to other function?
    if ((generate_descriptions || !clone) &&
	FileUtils::Exists ("/usr/bin/create_package_descr"))
    {
	y2milestone ("creating packages descriptions...");
	cmd	= sformat("/usr/bin/create_package_descr -d %1 -C -F -o %2",
	    rpm_path, tmpdir);
	SCR::Execute (.target.bash, cmd, $["LANG":"C"]);
	y2milestone ("... done");
    }
    out = (map) SCR::Execute (.target.bash_output,
	sformat ("ls -A1 %1/packages.* 2>/dev/null", tmpdir));
    string lang	= "en";
    map packages_descr	= current_product["packages_descr"]:$[];
    foreach (string file, splitstring (out["stdout"]:"", "\n"), {
	list f	= splitstring (file, ".");
	lang	= f[size(f)-1]:"en";
	if (lang == "gz") // fortunatelly, there is no 'gz' locale...
	{
	    if (size (f) > 2)
		lang	= f[size(f)-2]:"en";
	    else return;
	}
	if (file == "" || lang == "DU" || lang == "FL") return;
	if (packages_descr[lang]:$[] == $[])
	{
	    packages_descr[lang]    = ReadPackagesFile (file);
	    return;
	}
	// now, we need to merge old data from packages_descr with currently
	// generated ones (TODO this works only for packages.en)
	foreach (string p, map d, (map<string,map>) ReadPackagesFile (file), {
	    if (!haskey (packages_descr[lang]:$[], p))
	    {
		y2debug ("new package %1", d);
		packages_descr[lang,p]	= d;
	    }
	});
    });
    current_product["packages_descr"]	= packages_descr;

    // we need the list of packages (for patterns), but asking
    // rpm would be slow, so let's get it from (already existing) descriptions
    if (clone)
    {
	y2milestone ("gathering available_packages from descriptions...");
	foreach (string p, map d, (map<string,map>) packages_descr[lang]:$[], {
	    if (p == "___global___") return;
	    list pkg_list	= splitstring (d["Pkg"]:"", " ");
	    string arch		= pkg_list[size (pkg_list) -1 ]:"noarch";
	    available_packages[arch] = add (available_packages[arch]:[], p);
	});
    }
    Progress::NextStage();
}

/**
 * Write the content file
 * @return success
 */
global boolean WriteContentFile (string base_path, list<map> content_data) {

    if (!FileUtils::Exists (base_path)) return false;

    string file	= "";
    foreach (map entry, content_data, {
	if (entry["value"]:"" != "")
	{
	    file = file + sformat ("%1 %2\n",entry["key"]:"",entry["value"]:"");
	    content_map[entry["key"]:""] = entry["value"]:"";
	}
    });

    return SCR::Write (.target.string, base_path + "/content", file);
}

/**
 * Write the readme/COPYING/COPYRIGHT... files in base_path
 * @return success
 */
global boolean WriteStringFiles (string base_path, map<string,string> files) {

    if (!FileUtils::Exists (base_path)) return false;

    boolean ret	= true;
    foreach (string file, string cont, files, {
	if (cont != "")
	    ret = ret && SCR::Write(.target.string, base_path +"/"+ file, cont);
    });
    return ret;
}

/**
 * generate the paths of media, data and description dirs
 */
global void GenerateDirectories (string base_path) {

    integer i = 1;
    integer no_of_medias	= 1; // FIXME layout is different for more media
    while (i <= no_of_medias)
    {
	string media_path	= sformat ("%1/media.%2", base_path, i);
	full_media_paths	= add (full_media_paths, media_path);
	i = i + 1;
    }
    full_data_path =sformat("%1/%2", base_path,content_map["DATADIR"]:"");
    full_descr_path = sformat ("%1/%2", base_path, content_map["DESCRDIR"]:"");
}

/**
 * Create the directory structure of the Add-On
 * @return success
 */
global boolean CreateAddOnStructure (string base_path) {

    if (!FileUtils::Exists (base_path)) return false;

    GenerateDirectories (base_path);
    // create the media's directories
    foreach (string dir, full_media_paths, {
	SCR::Execute (.target.mkdir, dir);
    });

    // create the data dir
    if (content_map["DATADIR"]:"" == "")
    {
	y2error ("DATADIR is : %1", content_map["DATADIR"]:"");
	return false;
    }

    SCR::Execute (.target.mkdir, full_data_path);

    // create the dirs for packages
    if (arch_directories == [])
    {
	foreach (string arch_dir, list pa, available_packages, {
	    if (arch_dir != "ZZZ_imported" && arch_dir != "ZZZ_required")
		SCR::Execute (.target.mkdir, full_data_path + "/" + arch_dir);
	});
    }

    SCR::Execute (.target.mkdir, full_descr_path);

    return true;
}

/**
 * Generate the package descriptions using create_package_descr
 */
global boolean GeneratePackageDescriptions () {

    if (!FileUtils::Exists ("/usr/bin/create_package_descr")) return false;

    string command = sformat ("/usr/bin/create_package_descr -d %1 -C -F -o %2",
	full_data_path, full_descr_path);
    SCR::Execute (.target.bash_output, command, $["LANG":"C"]);
    return true;

}

/**
 * Write the package descriptions edited by user
 * @path descr_path full path to directory with package descriptions (DESCRDIR)
 * @path map with package descriptions
 */
global boolean WritePackageDescriptions (string descr_path, map descr) {

    if (!FileUtils::Exists (descr_path)) return false;

    boolean ret	= true;
    if (descr == $[]) return ret;
    foreach (string lang, map data, (map<string,map>)descr, {
	string file_path	= descr_path + "/packages." + lang;
	ret	= ret && PackagesDescr::Write (file_path,(map<string,any>)data);
	if (compress_package_descriptions && gzip_installed ())
	{
	    y2debug ("compressing %1 file: %2", file_path, SCR::Execute (
		.target.bash, sformat ("gzip %1", file_path)));
	}
    });
    if (ret) // copy the rest of files, generated earlier
    {
	SCR::Execute (.target.bash, sformat (
	    "/bin/rm -f '%1/packages' '%1/packages.DU*' '%1/packages.FL*'",
	    descr_path));
	foreach (string file, [ "packages", "packages.DU", "packages.FL"], {
	    string pth		= tmpdir + "/" + file;
	    boolean compress	= false;
	    if (!FileUtils::Exists (pth) && FileUtils::Exists (pth + ".gz"))
		pth = pth + ".gz";
	    else if (compress_package_descriptions)
		compress	= true;
	    string cmd = sformat("/bin/cp %1 '%2'", pth, descr_path);
	    SCR::Execute (.target.bash, cmd, $["LANG":"C"]);
	    if (compress)
	    {
		SCR::Execute (.target.bash,
		    sformat ("gzip %1/%2", descr_path, file));
	    }
	});
    }

    /* no need to read now, already done in UI or CLI
    if (extra_prov_file != "" && FileUtils::Exists (extra_prov_file))
	extra_prov	= (string) SCR::Read (.target.string, extra_prov_file);
    */
    string extra_prov	= current_product["extra_prov"]:"";
    if (extra_prov != "" && extra_prov != nil)
	SCR::Write (.target.string, descr_path + "/EXTRA_PROV",extra_prov);

    return ret;
}

/**
 * Generate ARCHIVES.gz, INDEX.gz and ls-lR.gz
 * @param base_path path to base output directory
 */
global boolean GenerateArchiveFiles (string base_path)
{
    if (!Package::Installed ("inst-source-utils") &&
	!FileUtils::Exists ("/usr/bin/mk_listings"))
    {
	y2error ("inst-source-utils not installed and mk_listings not present");
	return false;
    }
    if (!FileUtils::Exists (base_path)) return false;

    map out = (map) SCR::Execute (.target.bash_output, sformat ("cd '%1';mk_listings .",base_path));
    if (out["stderr"]:"" != "")
    {
	y2warning ("mk_listings returns %1", out);
    }
    return true;
}


/**
 * Create the patches files
 * @param base_path path to base output directory
 * @param list with patches file contents
 * @return success
 */
global boolean WritePatchesFiles (string base_path, list<string> p_files)
{
    if (!FileUtils::Exists (base_path)) return false;

    integer i	= 1;
    foreach (string cont, p_files, {
	string file_path = base_path + sformat ("/media.%1/patches", i);
	if (cont != "")
	{
	    SCR::Write (.target.string, file_path, cont);
	}
	i	= i + 1;
    });
    return true;
}
/**
 * Create the products file FIXME editor - see ExpertSettingsDialog3
 * @param base_path path to base output directory
 * @return success
 */
global boolean WriteProductsFiles (string base_path, list<string> p_files)
{
    if (!FileUtils::Exists (base_path)) return false;

    integer i	= 1;
    if (p_files == [])	p_files = [ "" ];
    foreach (string cont, p_files, {
	if (cont == "")
	{
	    cont = "/\t" +
		content_map["DISTPRODUCT"]:"" + " " +
		content_map["VERSION"]:"";
	}
	SCR::Write (.target.string,
	    sformat ("%1/media.%2/products", base_path, i), cont);
	i	= i + 1;
    });
    return true;
}

/**
 * Write the media.n/media files
 * @param base_path path to base output directory
 * @param m_files list of media files contents
 * @param next content of nextmedia file
 * @return success
 */
global boolean WriteMediaFiles (string base_path, list<string> m_files, string next)
{
    if (!FileUtils::Exists (base_path)) return false;

    integer i	= 1;
    if (m_files == [])	m_files = [ "" ];
    foreach (string cont, m_files, {
	string media_path = base_path + sformat ("/media.%1", i);
	if (cont == "")
	{
	    string media_id	= "";
	    map out = (map) SCR::Execute (.target.bash_output,
		"date +%Y%m%d%H%M%S");
	    media_id	= deletechars (out["stdout"]:"", "\n");
	    cont = content_map["VENDOR"]:"" + "\n" + media_id;
	    if (i == 1)
		cont	= cont + "\n" + size (m_files);
	}
	SCR::Write (.target.string, media_path + "/media", cont);
	// write nextmedia file if not empty
	if (i == 1 && next != "")
	    SCR::Write (.target.string, media_path + "/nextmedia", next);
	i	= i + 1;
    });
    return true;
}

// write info.txt file
global boolean WriteInfoFile (string info_dir, string info) {

    if (info != "" && info != nil)
	SCR::Write (.target.string, info_dir + "/info.txt", info);
    return true;
}


/**
 * Write the text of available licenses to correct places
 * @path descr_path full path to directory with package descriptions (DESCRDIR)
 * @param base_path full path to base output directory
 * @patram files map of license files and their contents ($[ name : content ])
 */
global boolean WriteLicensesFiles (string descr_path, string base_path, map<string,string> files)
{

    if (!FileUtils::Exists (base_path))
    {
	y2warning ("no %1 directory exists...", base_path);
	return false;
    }

    boolean ret	= true;
    string cmd	= "";
    foreach (string file, string cont, files, {
	if (cont != "")
	{
	    integer pos	= findlastof (file, ".");
	    if (pos == nil || substring (file, pos) != ".txt")
		file	= file + ".txt";
	    cmd	= cmd + " " + file;
	    ret = ret && SCR::Write (.target.string, tmpdir + "/"+ file ,cont);
	    if (file == "license.txt")
		SCR::Write (.target.string, tmpdir + "/EULA.txt", cont);
	}
    });
    // tar + gzip the licenses into one file
    if (ret && cmd != "")
    {
	cmd     = sformat ("cd %1; tar -czf %2/license.tar.gz license*.txt",
	    tmpdir, base_path);
	map out = (map) SCR::Execute (.target.bash_output, cmd);
	if (out["stderr"]:"" != "")
	{
	    y2warning ("%1 returned %2", cmd, out);
	    ret	= false;
	}
    }
    // merge the license of packages into EULA.txt
    if (!FileUtils::Exists (tmpdir + "/EULA.txt"))
	SCR::Execute (.target.bash, sformat ("touch %1/EULA.txt", tmpdir));
    if (FileUtils::Exists ("/usr/bin/packages2eula.pl"))
    {
	SCR::Execute (.target.bash_output, sformat(
	"/usr/bin/packages2eula.pl -p %1/packages.en -o %2/EULA.txt 2>/dev/null"
	, descr_path, tmpdir));
    }
    if (FileUtils::GetSize (tmpdir + "/EULA.txt") > 0)
	SCR::Execute (.target.bash, sformat ("cp %1/EULA.txt %2/", tmpdir,
	    base_path));

    return ret;
}

/**
 * Write all files with patterns definitions
 * @path descr_path full path to directory with package descriptions (DESCRDIR)
 * @param base_path path to base output directory
 */
global boolean WritePatterns (string descr_path, string base_path) {

    if (!FileUtils::Exists (base_path) || !FileUtils::Exists (descr_path))
    {
	y2warning ("%1 or %2 directory not available...",base_path, descr_path);
	return false;
    }

    boolean ret		= true;
    list<string> names	= [];
    foreach (string name, map pattern, current_product["patterns"]:$[], {
	string filename	= CreatePatternFullName (pattern, true);
	if (filename == "")
	    return;
	names		= add (names, filename);
	string file	= sformat ("=Ver: %1\n\n=Pat: %2\n",
	    pattern["Ver"]:pattern_descr["Ver","defval"]:"",
	    pattern["Pat"]:"");
	pattern	= remove (remove (pattern, "Ver"), "Pat");
	foreach (string key, any val, (map<string,any>) pattern, {
	    map descr		= pattern_descr[key]:$[];
	    // substring (key,0,3) is because of Des.lang, Sum.lang and Cat.lang
	    string shortkey	= substring (key,0,3);
	    if (pattern_descr[shortkey]:$[] != $[] &&
		substring (key, 3, 1) == ".")
		descr		= pattern_descr[shortkey]:$[];
	    if (val == nil || val == "" || val == [] || descr["internal"]:false)
		return;
	    if (file != "")
		file	= file + "\n";
	    if (descr["type"]:"" == "boolean")
		val	= (boolean) val ? "true" : "false";
	    else if (descr["type"]:"" == "package-list")
		val	= mergestring ((list<string>)val, "\n");
	    if (descr["single_line"]:false)
	    {
		file = file + sformat ("=%1: %2\n", key, val);
	    }
	    else
	    {
		file = file + sformat ("+%1:\n%2\n-%1:\n", key, val);
	    }
	});
	SCR::Write (.target.string, descr_path + "/" + filename, file);
	if (compress_patterns && gzip_installed ())
	{
	    y2debug ("compressing pattern file: %1", SCR::Execute (
		.target.bash, sformat ("gzip %1/%2",descr_path,filename)));
	}
    });
    if (names != [])
	ret = SCR::Write (.target.string, descr_path + "/patterns",
	    mergestring (names, "\n"));
    return ret;
}

/**
 * Copy the packages from the source directory to target
 * @param in_path source path
 * @param base_path destination directory
 * @return success
 */
global boolean CopyRPMs (string in_path, string base_path) {

    if (in_path == "")
	return true;

    if (!FileUtils::Exists (base_path) || !FileUtils::Exists (in_path))
	return false;
    // packages in the directories with arch name
    if (arch_directories != [])
    {
	foreach (string arch, arch_directories, {
	    string dir	= in_path + "/" + arch;
	    if (FileUtils::Exists (dir))
	    {
		y2milestone ("copying from %1 to %2...", dir, full_data_path);
		SCR::Execute (.target.bash_output,
		    sformat ("/bin/cp -r %1 '%2/'", dir, full_data_path));
	    }
	});
    }
    // packages not in directories but we have asked them for arch's
    else if (available_packages != $[])
    {
	foreach (string arch, list pa, available_packages, {
	    string out_dir	= full_data_path + "/" + arch;
	    if (arch != "ZZZ_imported" && arch != "ZZZ_required" &&
		FileUtils::Exists (out_dir))
	    {
		// arch_directories will be needed later for CreateMD5SUMS and
		// resign_packages
		arch_directories	= (list<string>)
		    union (arch_directories, [arch]);
		if (size (package2filename) > 0 && arch != "src")
		{
		    foreach (string p, (list<string>) pa, {
			SCR::Execute (.target.bash, sformat (
			    "/bin/cp %1 '%2/'", package2filename[arch,p]:"", out_dir));
		    });
		}
		else if (size (srcpackage2filename) > 0 && arch == "src")
		{
		    foreach (string p, (list<string>) pa, {
			SCR::Execute (.target.bash, sformat (
			    "/bin/cp %1 '%2/'", srcpackage2filename[arch,p]:"", out_dir));
		    });
		}
		else
		{
		    foreach (string p, (list<string>) pa, {
			SCR::Execute (.target.bash, sformat (
			    "/bin/cp %1/%2*.rpm '%3/'", in_path, p, out_dir));
		    });
		}
	    }
	});
    }
    return true;
}


/**
 * Write the modification of installation workflow
 * @param base_path path to base output directory
 * @param desc_path path to workflow description file
 * @param packages list with paths of packages to be included in y2update.tgz
 * @param y2update path to existing y2update.tgz
 */
boolean WriteWorkflow (string base_path,string desc_path, list<string> packages,
		       string y2update_p)
{
    if (!FileUtils::Exists (base_path)) return false;

    boolean ret = true;
    if (desc_path != "" && FileUtils::Exists (desc_path))
    {
	y2milestone ("writing %1 as %2/installation.xml", desc_path, base_path);
	SCR::Execute (.target.bash, sformat ("cp '%1' '%2/installation.xml'",
	    desc_path, base_path));
    }
    if (y2update_p != "")
    {
	SCR::Execute (.target.bash, sformat ("cp '%1' '%2/y2update.tgz'",
	    y2update_p, base_path));
    }
    else if (packages != [])
    {
	string y2update_dir	= tmpdir + "/y2update";
	SCR::Execute (.target.mkdir, y2update_dir);
	foreach (string p, packages, {
	    y2milestone ("extracting %1", p);
	    string cmd = sformat ("cd '%1'; rpm2cpio %2 | cpio -imud 2>&1",
		y2update_dir, p);
	    y2debug ("extracting rpm: %1", cmd);
	    map out = (map) SCR::Execute (.target.bash_output, cmd);
	    if (out["stderr"]:"" != "")
	    {
		y2warning ("%1 returned %2", cmd, out);
	    }
	});
	string cmd = sformat ("cd '%2'; tar -czf '%1/y2update.tgz' .",
	    base_path, y2update_dir);
	y2debug ("tar cmd: %1", cmd);
	map out = (map) SCR::Execute (.target.bash_output, cmd);
	if (out["stderr"]:"" != "")
	{
	    y2warning ("%1 returned %2", cmd, out);
	    ret	= false;
	}
    }
    return ret;
}

/**
 * Generate Changelog for the product
 * @param base_path base output path
 */
boolean GenerateChangelog (string base_path)
{
    if (!Package::Installed ("inst-source-utils") &&
	!FileUtils::Exists ("/usr/bin//usr/bin/mk_changelog"))
    {
	y2error("inst-source-utils not installed and mk_changelog not present");
	return false;
    }
    if (!FileUtils::Exists (base_path)) return false;

    map out = (map) SCR::Execute (.target.bash_output,
	sformat ("cd '%1'; mk_changelog",base_path),
	$[ "ROOT_ON_CD" : content_map["DATADIR"]:""]);
    if (out["stderr"]:"" != "")
    {
	y2warning ("mk_changelog returns %1", out);
    }
    return true;

}

/**
 * Generate servicepack.tar.gz archive for bootable media
 * @param base_path base output path
 */
boolean WriteServicepackArchive (string base_path)
{
    if (!FileUtils::Exists (base_path)) return false;

    boolean ret = true;
    if (!bootable) return ret;

    string spdir	= tmpdir + "/servicepack";
    SCR::Execute (.target.mkdir, spdir);

    SCR::Execute (.target.bash,
	sformat ("cp %1/content* '%2/'", base_path, spdir));

    SCR::Execute (.target.bash,
	sformat ("cp %1/gpg-pubkey* '%2/'", base_path, spdir));

    SCR::Execute (.target.bash,
	sformat ("cp -r %1/media.1 '%2/'", base_path,spdir));

    // copy descriptions (with the stucture)
    string descr_path = sformat ("%1/%2", spdir, content_map["DESCRDIR"]:"");
    SCR::Execute (.target.mkdir, descr_path);
    SCR::Execute (.target.bash,
	sformat("cp %1/* '%2/'", full_descr_path, descr_path));

    if (current_product["workflow_path"]:"" != "")
	SCR::Execute (.target.bash, sformat("cp '%1/installation.xml' '%2/'",
	    base_path, spdir));

    if (FileUtils::Exists (base_path + "/y2update.tgz"))
	SCR::Execute (.target.bash, sformat("cp '%1/y2update.tgz' '%2'",
	    base_path, spdir));

    // finally, create the archive
    string cmd = sformat ("cd '%1'; tar -czf '%2/servicepack.tar.gz' .",
	spdir, base_path);
    y2debug ("tar cmd: %1", cmd);
    map out = (map) SCR::Execute (.target.bash_output, cmd);
    if (out["stderr"]:"" != "")
    {
	y2warning ("%1 returned %2", cmd, out);
	ret	= false;
    }
    return ret;
}

// helper to check if directory contains any files (-type f)
boolean dir_has_files (string dir) {

    if (!FileUtils::Exists (dir)) return false;

    map out = (map) SCR::Execute (.target.bash_output,
	sformat ("cd '%1'; find -maxdepth 1 -type f | wc -l", dir));
    integer count = tointeger(deletechars(out["stdout"]:"0","\n"));
    return (count != nil && count > 0);
}

/**
 * Create MD5SUMS files
 * @return success
 */
global boolean CreateMD5SUMS (string base_path) {

    if (!FileUtils::Exists (base_path)) return false;

    // after CopyRPMs, arch_directories contains list of directories with RPM's
    list<string> dirs_for_md5 = maplist (string arch_dir, arch_directories, {
	return full_data_path + "/" + arch_dir;
    });
    dirs_for_md5	= add (dirs_for_md5, full_descr_path);
    foreach (string full_path, dirs_for_md5, {
	if (dir_has_files (full_path))
	{
	    // whole dir was copied -> also with original MD5SUMS
	    if (FileUtils::Exists (full_path + "/MD5SUMS"))
	    {
		SCR::Execute (.target.bash, sformat("cd '%1'; chmod +w . MD5SUMS; rm MD5SUMS", full_path));
	    }
	    string command = sformat("cd '%1'; md5sum -- * > MD5SUMS", full_path);
	    map out =
		(map)SCR::Execute (.target.bash_output, command, $["LANG":"C"]);
	    if (out["exit"]:0 != 0)
		y2error ("%1 failed: %2", command, out);
	}
    });

    // sha1sums of descriptions
    map out = (map) SCR::Execute (.target.bash_output, sformat ("ls -A1 '%1'", full_descr_path));
    foreach (string file, splitstring (out["stdout"]:"", "\n"), {
	if (file == "") return;
	out = (map) SCR::Execute (.target.bash_output,
	    sformat ("cd '%1' && sha1sum -- %2", full_descr_path, String::Quote (file)),
	    $["LANG" : "C"]);
	string command	= sformat ("echo 'META SHA1 %1' >> '%2/content'",
	    deletechars (out["stdout"]:"", "\n"), base_path);
	SCR::Execute (.target.bash, command, $["LANG" : "C"]);
    });

    // sha1sums of the rest of interesting files
    foreach (string file, [ "installation.xml", "license.tar.gz", "media.1/info.txt"],
    {
	if (FileUtils::Exists (base_path + "/" + file))
	{
	    out = (map) SCR::Execute (.target.bash_output,
		sformat ("cd '%1' && sha1sum -- %2", base_path, String::Quote (file)), $["LANG" : "C"]);
	    string command = sformat ("echo 'HASH SHA1 %1' >> '%2/content'",
		deletechars (out["stdout"]:"", "\n"), base_path);
	    SCR::Execute (.target.bash, command, $["LANG" : "C"]);
	}
    });
    return true;
}

/**
 * Report the error with failed gpg and ask for possible new
 * entering of pw
 * @param string message from gpg
 * @param boolean if we are asking because of signing failure
 */
string AskForPassphrase (string message, boolean failure) {

    string pw	= nil;
    term info_term	= failure ? `VBox (
	`HSpacing (70),
	// error label
	`Left (`Label (_("Signing of the product failed."))),
	message == "" ?
	    `VSpacing (0) :
	    `RichText (mergestring (splitstring (
		String::EscapeTags (message),"\n"),"<br>")
	    )
    ) : `VSpacing ();
    term input_term	= failure ?  `HBox (
		`Left (`CheckBox (`id (`again), `opt (`notify),
		    // checkbox label
		    _("Try again with different passphrase"))),
		`Password (`id (`pw1), "")
    ) : `VBox (
	`Password (`id (`pw1), message)
    );
    UI::OpenDialog (`opt(`decorated), `HBox (`HSpacing (0.5),
	`VBox (
	    info_term,
	    input_term,
	    `PushButton (`id(`ok),`opt(`key_F10), Label::OKButton()),
	    `VSpacing (0.5)
	), `HSpacing (0.5))
    );
    UI::ChangeWidget (`id (`pw1), `Enabled, !failure);

    any ret	= `cancel;
    repeat
    {
	ret	= UI::UserInput ();
	if (ret == `again)
	{
	    boolean enabled	= (boolean)UI::QueryWidget(`id(`pw1), `Enabled);
	    UI::ChangeWidget (`id (`pw1), `Enabled, !enabled);
	}
	if (ret == `ok)
	{
	    if (UI::QueryWidget (`id(`pw1), `Enabled) == true)
	    {
		pw	= (string) UI::QueryWidget (`id(`pw1), `Value);
	    }
	}
    } until (ret == `ok || ret == `cancel);

    UI::CloseDialog ();
    return pw;
}

/**
 * Sign the add-on
 */
global boolean SignAddOn (string base_path, string key) {

    string passphrase	= passphrases[key]:"";
    if (key == "" || passphrase == "")
    {
	y2warning ("No GPG key or passphrase provided - signing skipped");
	return true;
    }

    string command = sformat ("gpg --list-secret-keys %1|grep '^sec'|sed -e 's/.*\\///;s/ .*//g;'|head -n 1", key);
    map out = (map)SCR::Execute (.target.bash_output, command, $["LANG" : "C"]);
    string local_key	= deletechars (out["stdout"]:"0","\n");

    out = (map)SCR::Execute (.target.bash_output, sformat ("gpg --list-secret-keys --with-colons %1| grep %2 | gawk -F: '{print $5}'| sed 's/........$//g'", key, local_key));
    string big_key	= deletechars (out["stdout"]:"0","\n");

    // save the passphrase
    string pw_path	= tmpdir + "/pw";
    SCR::Write (.target.string, pw_path, passphrase);

    // export the key:
    command = sformat ("gpg --export -a %1 > '%2/gpg-pubkey-%3-%1.asc'",
	local_key, base_path, big_key);
    SCR::Execute (.target.bash, command, $["LANG" : "C"]);

    // make a sha1 sum of that key (content file is modified last time)
    out = (map) SCR::Execute (.target.bash_output,
	sformat ("cd '%1'; ls -A1 gpg-pubkey*", base_path));

    foreach (string file, splitstring (out["stdout"]:"", "\n"), {
	if (file == "") return;
	out = (map) SCR::Execute (.target.bash_output,
	    sformat ("cd '%1' && sha1sum -- %2", base_path, String::Quote (file)),
	    $["LANG" : "C"]);
	string command	= sformat ("echo 'KEY SHA1 %1' >> '%2/content'",
	    deletechars (out["stdout"]:"", "\n"), base_path);
	SCR::Execute (.target.bash, command, $["LANG" : "C"]);
    });
    while (true)
    {
	// sign the content file
	SCR::Execute (.target.bash, sformat ("rm -f '%1/content.asc'",
	    base_path));
	out	= (map) SCR::Execute (.target.bash_output, sformat("gpg --batch --no-tty --passphrase-fd 0 --detach-sign -u %1 -a '%2/content' < %3",
	    local_key, base_path, pw_path)
	);
	if (out["exit"]:0 != 0)
	{
	    if (Mode::commandline ())
		Report::Error (out["stderr"]:"");
	    else
	    {
		passphrase	= AskForPassphrase (out["stderr"]:"", true);
		if (passphrase != nil)
		{
			SCR::Write (.target.string, pw_path, passphrase);
			continue;
		}
	    }
	    SCR::Execute (.target.remove, pw_path);
	    return false;
	}
	else break;
    }

    SCR::Execute (.target.bash,
	sformat("gpg --export -a %1 > '%2/content.key'",local_key, base_path));

    // sign the packages
    if (current_product["resign_packages"]:false)
    {
	string expect	= tmpdir + "/sign.ex";
	SCR::Write (.target.string, expect,
	    sformat (expect_script, key, passphrase));
	list<string> dirs = maplist (string arch_dir, arch_directories, {
	    return full_data_path + "/" + arch_dir;
	});
	foreach (string full_path, dirs, {
	    if (dir_has_files (full_path))
	    {
		string cmd = sformat ("LANG=C expect %1 %2/*.rpm", expect, full_path);
		out = (map) SCR::Execute (.target.bash_output, cmd);
	    }
	});
	SCR::Execute (.target.bash, sformat ("rm %1", expect));
    }


    // sign products file
    string products_path = full_media_paths[0]:"" + "/products";
    if (FileUtils::Exists (products_path))
    {
	SCR::Execute (.target.bash, sformat ("rm -f '%1.asc'", products_path));
	SCR::Execute (.target.bash,
	    sformat("gpg --batch --no-tty --passphrase-fd 0 --detach-sign -u %1 -a '%2' < %3",
	    local_key, products_path, pw_path));
	SCR::Execute (.target.bash,
	    sformat("gpg --export -a %1 > '%2.key'", local_key,products_path));
    }
    SCR::Execute (.target.remove, pw_path);
    return true;
}

/**
 * Create directory.yast files (the last step)
 * @return success
 */
global boolean CreateDirectoryYaSTFiles (string base_path) {

    if (!FileUtils::Exists (base_path)) return false;

    foreach (string dir, (list<string>) merge (
	[base_path, full_descr_path], full_media_paths),
    {
	SCR::Execute (.target.bash_output, sformat ("cd '%1'; ls -A1 -p | grep -v 'directory.yast' > directory.yast", dir), $["LANG" : "C"]);
    });
    return true;
}

/**
 * Create an ISO image of the product
 */
global boolean CreateISOImage (string dir_path, string iso_p, string name) {

    if (!current_product["iso"]:false) return true;

    if (!FileUtils::Exists (dir_path) || !FileUtils::Exists (iso_p)) return false;

    if (name == "")
	name	= sformat ("%1-%2-%3",
	    tolower (content_map["DISTPRODUCT"]:content_map["PRODUCT"]:"addon"),
	    content_map["DISTVERSION"]:"", content_map["DEFAULTBASE"]:"");
    if (!issubstring (name, ".iso"))
	name	= name + ".iso";
    current_product["iso_name"]	= name; // ??

    // possible options -allow-leading-dots
    string cmd	= sformat("mkisofs -r -J -l -o '%1/%2' '%3'",iso_p, name, dir_path);
    map out	= (map) SCR::Execute (.target.bash_output, cmd);
    if (out["exit"]:0 != 0)
    {
	y2warning ("%1 returned %2", cmd, out);
    }
    return true;
}

/**
 * Reset all settings related to current product
 */
global void ResetCurrentProduct () {

    current_product	= current_product_skel;
    generate_descriptions = false;
    clone		= false;

    available_packages  = $[];
    package2filename	= $[];
    srcpackage2filename = $[];

    // TODO move into current_product as well?
    content		= [];
    content_map		= $[];

    // reset global variables, that are generated for each product
    full_media_paths	= [];
    full_descr_path	= "";
    full_data_path	= "";
}

/**
 * save the data with current configuration into global list
 * + reset the current product map
 */
global void CommitCurrentProduct () {

    map modified_product	= union (current_product, $[
	"content_map"		: content_map,
	"available_packages"	: available_packages,
	"arch_directories"	: arch_directories,
	"package2filename"	: package2filename,
	"srcpackage2filename"	: srcpackage2filename,
	"generated"		: true,// Commit is after everything was entered
    ]);
    if (selected_product == -1)
	add_on_products = add (add_on_products, modified_product);
    else
    {
	integer i	= -1;
	add_on_products	= maplist (map product, add_on_products, {
	    i	= i + 1;
	    return (i == selected_product) ? modified_product : product;
	});
    }
    ResetCurrentProduct ();
    modified	= true;
}

global void SelectProduct (map product) {

    current_product	= product;
    content_map		= product["content_map"]:$[];

    // generate content from content_map
    content	= [];
    foreach (string key, map entry, content_descr, {
	if (content_map[key]:"" != "")
	    entry["value"]	= content_map[key]:"";
	content	= add (content, entry);
    });
    foreach (string key, string val, content_map, {
	if (!haskey (content_descr, key) && issubstring (key, "."))
	{
	    y2debug ("key %1 not in descr", key);
	    map entry	=
		content_specials[substring (key,0,findfirstof (key,"."))]:$[];
	    entry["key"]	= key;
	    entry["value"]	= val;
	    content = add (content, entry);
	}
    });
    available_packages	= product["available_packages"]:$[];
    arch_directories	= product["arch_directories"]:[];
    package2filename	= product["package2filename"]:$[];
    srcpackage2filename	= product["srcpackage2filename"]:$[];
}

/**
 * Write all AddOn products configurations
 */
global boolean Write () {

    add_on_products	= maplist (map product, add_on_products, {
	// these could be generated, no need to save...
	foreach (string key, ["available_packages", "arch_directories",
	    "package2filename", "srcpackage2filename", "generated"], {
	    if (haskey (product, key))
		product	= remove (product, key);
	});
	return product;
    });
    return SCR::Write (.target.ycp, add_on_products_file, add_on_products);
}


/**
 * prepare the data of current product for a build
 * (neccessary because input packages could get changed)
 */
global boolean PrepareBuild () {

    if (!current_product["generated"]:false)
    {
	FillContentDefaults ();
	// TODO not everything generated by FillContentDefaults is needed?
    }
    string key	= current_product["gpg_key"]:"";
    if (current_product["ask_for_passphrase"]:false &&
	key != "" && passphrases[key]:"" == "" && !Mode::commandline ())
    {
	// ask for pw now
	passphrases[key]	= AskForPassphrase (
	    sformat (_("Passphrase for GPG key %1"), key), false);
    }
}

/**
 * Write all add-on-creator settings
 * @return true on success
 */
global boolean BuildAddOn () {

    string base_output_path	= current_product["base_output_path"]:"";

    // AddOnCreator Build dialog caption
    string caption	= _("Creating the Add-On");

    list<string> stages	= [
	    // Progress stage
	    _("Write the content file"),
	    // Progress stage
	    _("Create the structure of the add-on"),
	    // Progress stage
	    _("Write the patterns"),
	    // Progress stage
	    _("Copy the packages"),
	    // Progress stage
	    _("Create MD5 sums"),
	    // Progress stage
	    _("Sign resulting product"),
    ];
    list<string> steps	= [
	    // Progress step
	    _("Writing the content file..."),
	    // Progress step
	    _("Creating the structure of the add-on..."),
	    // Progress stage
	    _("Writing the patterns..."),
	    // Progress step
	    _("Copying the packages..."),
	    // Progress step
	    _("Creating MD5 sums..."),
	    // Progress stage
	    _("Signing resulting product..."),
    ];

    if (current_product["iso"]:false)
    {
	// Progress stage
	stages	= add (stages, _("Create ISO image"));
	// Progress step
	steps	= add (steps, _("Creating ISO image..."));
    }
    // Progress finished
    steps   = add (steps, _("Finished"));

    Progress::New (caption, " ", size (stages), stages, steps, "");

    Progress::NextStage();

    if (current_product["iso"]:false)
    {
	string iso_path	= current_product["iso_path"]:"";
	if (iso_path == "")
	{
	    current_product["iso_path"]	= base_output_path;
	    if (!only_sign_product)
	    {
		base_output_path= tmpdir + "/output";
		SCR::Execute (.target.mkdir, base_output_path);
	    }
	}
	else if (!FileUtils::Exists (iso_path))
	    SCR::Execute (.target.mkdir, iso_path);
    }

    if (only_sign_product)
    {
	GenerateDirectories (base_output_path);
	Progress::NextStage();
	Progress::NextStage();
	Progress::NextStage();
	Progress::NextStage();
    }
    else
    {
	if (!WriteContentFile (base_output_path, content))
	{
	    // Error message (do not translate 'content'
	    Report::Error (_("Cannot write content file."));
	    return false;
	}

	WriteStringFiles (base_output_path,
	    current_product["readme_files"]:$[]);
	WriteStringFiles (base_output_path,
	    current_product["copying_files"]:$[]);
	WriteStringFiles (base_output_path,
	    current_product["copyright_files"]:$[]);

	Progress::NextStage();

	if (!CreateAddOnStructure (base_output_path))
	{
	    // Error message
	    Report::Error (_("Cannot create the output directory structure."));
	    return false;
	}

	WritePatchesFiles (base_output_path,
	    current_product["patches_files"]:[]);

	WriteProductsFiles (base_output_path,
	    current_product["products_files"]:[]);

	WriteMediaFiles (base_output_path,
	    current_product["media_files"]:[],
	    current_product["nextmedia"]:"");

	WriteInfoFile (full_media_paths[0]:"",
	    current_product["info"]:"");

	Progress::NextStage();

	WritePatterns (full_descr_path, base_output_path);

	Progress::NextStage();

	CopyRPMs (current_product["rpm_path"]:"", base_output_path);

	WritePackageDescriptions (
	    full_descr_path,
	    current_product["packages_descr"]:$[]);

	WriteLicensesFiles (full_descr_path, base_output_path,
	    current_product["license_files"]:$[]);

	WriteWorkflow (base_output_path,
	    current_product["workflow_path"]:"",
	    current_product["y2update_packages"]:[],
	    current_product["y2update_path"]:"");

	Progress::NextStage();

	GenerateArchiveFiles (base_output_path);

	CreateMD5SUMS (base_output_path);
    }

    Progress::NextStage();

    if (current_product["changelog"]:false)
	GenerateChangelog (base_output_path);

    WriteServicepackArchive (base_output_path);

    if (!SignAddOn (base_output_path, current_product["gpg_key"]:""))
	return false;

    CreateDirectoryYaSTFiles (base_output_path);

    if (current_product["iso"]:false)
    {
	Progress::NextStage();
	CreateISOImage (base_output_path,
	    current_product["iso_path"]:"",
	    current_product["iso_name"]:"");
    }

    Progress::NextStage();

    ResetCurrentProduct ();

    return true;
}

/**
 * Export the settings about current Add-On product
 */
global map Export () {

    y2warning ("not implemented");
    return $[];
}

global boolean Import (map settings) {

    y2warning ("not implemented");
    return false;
}

/* EOF */
}
