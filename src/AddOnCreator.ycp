/* ------------------------------------------------------------------------------
 * Copyright (c) 2006 Novell, Inc. All Rights Reserved.
 *
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of version 2 of the GNU General Public License as published by the
 * Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program; if not, contact Novell, Inc.
 *
 * To contact Novell about this file by physical or electronic mail, you may find
 * current contact information at www.novell.com.
 * ------------------------------------------------------------------------------
 */

/**
 * File:	modules/AddOnCreator.ycp
 * Package:	Configuration of add-on-creator
 * Summary:	AddOnCreator settings, input and output functions
 * Authors:	Jiri Suchomel <jsuchome@suse.cz>
 *
 * $Id$
 *
 * Representation of the configuration of add-on-creator.
 * Input and output routines.
 */

{

module "AddOnCreator";
textdomain "add-on-creator";

import "Arch";
import "Directory";
import "FileUtils";
import "Label";
import "Mode";
import "Package";
import "PackageSystem";
import "PackagesDescr";
import "Progress";
import "Report";
import "String";

/**
 * where the configurations are stored
 */
string add_on_products_file	= Directory::vardir +"/add_on_products.ycp";

/**
 * list of all configured AddOn products
 */
global list<map> add_on_products	= [];

/**
 * map of the Add-On product currently in use
 */
global map current_product		= $[
    // path to output directory
    "base_output_path"	: "",
    // path to directory with RPM's
    "rpm_path"		: nil,
    // path to directory with RPM's, used only for building patterns
    // and not present on AddOn
    "required_rpm_path"	: "",
    // map of patterns for current product
    "patterns"		: $[],
    // description of packages (initially generated by create_package_descr
    "packages_descr"	: $[],
    // the contents of products files
    "products_files"	: [],
    // the contents of media files
    "media_files"	: [],
    // the contents of patches files
    "patches_files"	: [],
    // the contents of info.txt file
    "info"		: "",
    // content of readme files
    "readme_files"	: $[
	"README"	: ""
    ],
    // content of license files (in media.1 dir)
    "license_files"	: $[
        "license"	: ""
    ],
    "copying_files"	: $[
	"COPYING"	: ""
    ],
    "copyright_files"	: $[
        "COPYRIGHT"	: ""
    ],
    // the contents of EXTRA_PROV file
    "extra_prov"	: "",
    // path to the file with EXTRA_PROV data
    "extra_prov_file"	: "",
    // the contents of nextmedia file
    "nextmedia"		: "",
    // paths with packages to be archived in y2update.tgz
    "y2update_packages"	: [],
    // path with y2update.tgz (alternative to y2update_packages)
    "y2update_path"	: "",
    // path to file with installation workflow (installation.xml)
    "workflow_path"	: "",
    // if iso image should be created from the final Add-On
    "iso"		: false,
    // where the iso image should be put
    "iso_path"		: "",
    // name of the iso image file
    "iso_name"		: "",
    // also sign all rpm's (see bug #287447)
    "resign_packages"	: false,
    // current GPG key
    "gpg_key"		: "",
];

// skeleton for current_product map (with keys and default values)
map current_product_skel	= current_product;

global integer selected_product	= -1;

/**
 * variables from content file + their description
 */
global list<map> content	= [];

global list<string> allowed_archs = [ "ppc", "ppc64", "ia64", "x86_64", "i686", "i586", "i486", "i386","noarch"];


map<string,map> content_descr	= $[
    "CONTENTSTYLE"	: $[
	    "key"	: "CONTENTSTYLE",
	    // label of content file key
	    "label"	: _("Content file style"),
	    // help text for content file CONTENTSTYLE key
	    "help"	: _("Must be the first tag of the content file"),
	    "value"	: "11",
	    "mandatory"	: true,
    ],
    "NAME"	: $[
	    "key"	: "NAME",
	    // label of content file key
	    "label"	: _("Product name"),
	    // help text for content file 'NAME' key
	    "help"	: _("For internal usage. Same restrictions as for package names apply."),
	    "mandatory"	: true,
    ],
    "BASEARCHS"	: $[
	    "key"	: "BASEARCHS",
	    // label of content file BASEARCHS key
	    "label"	: _("Product architectures"),
	    // help text for content file 'BASEARCHS' key
	    "help"	: _("Space-separated list of product architectures for. Matches the available product-release packages architectures. "),
	    "mandatory"	: true
    ],
    "VERSION"	: $[
	    "key"       : "VERSION",
	    // label of content file 'VERSION' key
	    "label"	: _("Product version and release"),
	    // help text for content file 'VERSION' key
	    "help"	: _("Product version and release as in RPM <tt>major.minor-release</tt>."),
	    "value"	: "1",
	    "mandatory"	: true,
    ],
    "RELEASE"		: $[
	    "key"	: "RELEASE",
	    // table item label
	    "label"	: _("The release number"),
	    "value"	: "0",
	    "mandatory"	: true,
    ],
    "DISTRIBUTION"	: $[
	    "key"	: "DISTRIBUTION",
	    // label of content file key
	    "label"	: _("Distribution name"),
	    // help text for content file 'DISTRIBUTION' key
	    "help"	: _("Some string denoting the distribution. The same string is most probably used in the .rpms to denote the distribution. Usually a composition of the name, version and architecture."),
    ],
    "DESCRDIR"		: $[
	    "key"	: "DESCRDIR",
	    // label of content file key
	    "label"	: _("Package description directory"),
	    "value"	: "suse/setup/descr",
	    // help text for content file 'DESCRDIR' key
	    "help"	: _("Package description directory (relative to product directory)."),
	    "mandatory"	: true,
    ],
    "DATADIR"		: $[
	    "key"	: "DATADIR",
	    // label of content file key
	    "label"	: _("Package data directory"),
	    // help text for content file 'DATADIR' key
	    "help"	: _("Package data directory (relative to product directory)."),
	    "value"	: "suse",
	    "mandatory"	: true,
    ],
    "LABEL"		: $[
	    "key"	: "LABEL",
	    // label of content file key
	    "label"	: _("Label"),
	    // help text for content file '' key
	    "help"	: _("UTF-8 encoded label. Default label if <b>LINGUAS</b> is omitted or no default language can be determined."),
    ],
    "LINGUAS"		: $[
	    "key"	: "LINGUAS",
	    // label of content file 'LINGUAS' key
	    "label"	: _("Languages"),
	    // help text for content file 'LINGUAS' key
	    "help"	: _("ISO language code or language code_country code."),
    ],
    "LANGUAGE"		: $[
	    "key"	: "LANGUAGE",
	    // label of content file 'LANGUAGE' key
	    "label"	: _("Default language"),
	    // help text for content file 'LANGUAGE' key
	    "help"	: _("Default language code."),
	    "type"	: "combo",
	    "allowed_values"	: nil,
    ],
    "PATTERNS"		: $[
	    "key"	: "PATTERNS",
	    // label of content file 'PATTERNS' key
	    "label"	: _("Preselected patterns"),
	    // help text for content file 'PATTERNS' key
	    "help"	: _("List of patterns preselected by the product."),
    ],
    "VENDOR"		: $[
	    "key"	: "VENDOR",
	    // label of content file key
	    "label"	: _("Vendor name"),
	    // help text for content file 'VENDOR' key
	    "help"	: _("Vendor name (free form)."),
	    "mandatory"	: true,
    ],
    "RELNOTESURL"	: $[
	    "key"	: "RELNOTESURL",
	    // label of content file 'RELNOTESURL' key
	    "label"	: _("Release notes URL"),
	    // help text for content file 'RELNOTESURL' key
	    "help"	: _("URL from which to fetch release notes."),
    ],
    "UPDATEURLS"	: $[
	    "key"	: "UPDATEURLS",
	    // label of content file 'UPDATEURLS' key
	    "label"	: _("Update URL"),
	    // help text for content file 'UPDATEURLS' key
	    "help"	: _("URL of the update source."),
    ],
];

// skeletons for special keys in content file
global map content_specials	= $[

    "LABEL"	: $[
	    // label of content file LABEL.lang key
	    "label"	: _("Language-specific label"),
	    // help text for content file 'LABEL.lang' key
	    "help"	: _("UTF-8-encoded <b>LABEL</b>. <tt>lang</tt> has the same syntax as the <b>LINGUAS</b> values. For each language in <b>LINGUAS</b>, a matching <b>LABEL.lang</b> is expected."),
	    "helplabel"	: "LABEL.lang",
    ],
];


// desctiption of pattern keys
global map<string,map> pattern_descr	= $[
    "name"	: $[
	"internal"	: true,
    ],
    "version"	: $[
	"label"		: _("Version"),
	"internal"	: true,
	"adapt_name"	: true,
	"defval"	: "1.0",
    ],
    "release"	: $[
	"label"		: _("Release"),
	"internal"	: true,
	"adapt_name"	: true,
	"defval"	: "1",
    ],
    "arch"	: $[
	"label"		: _("Architecture"),
	"internal"	: true,
	"type"		: "combo",
	"allowed_values": allowed_archs,
	"adapt_name"	: true,
	"defval"	: "noarch",
    ],
    "Pat"	: $[
	"single_line"	: true,
    ],
    "Ver"	: $[
	"defval"	: "5.0",
	"single_line"	: true,
    ],
    "Sum"	: $[
	"label"		: _("Summary"),
	// help text for 'Sum' pattern key
	"help"		: _("One line label in the default language"),
	// help text for 'Sum.lang' pattern key
	"lang_help"	: _("One line language-specific label."),
	"single_line"	: true,
    ],
    "Des"	: $[
	// label for 'Des' pattern key
	"label"		: _("Description"),
	"type"		: "multiline",
	// help text for 'Des' pattern key
	"help"		:_("Multiple line description in the default language"),
	// help text for 'Des.lang' pattern key
	"lang_help"	:_("Multiple line description, language-specific.")
    ],
    "Cat"	: $[
	// label for 'Cat' pattern key
	"label"		: _("Category"),
	// help text for 'Cat' pattern key
	"help"		: _("One line category in the default language used to group patterns. Categories are intended for the user and can be specified freely."),
	// help text for 'Cat.lang' pattern key
	"lang_help"	: _("Language-specific version of the category."),
	"single_line"	: true,
    ],
    "Vis"	: $[
	// label for 'Vis' pattern key
	"label"		: _("Visibility"),
	// help text for 'Vis' pattern key
	"help"		: _("Set whether the pattern should be visible in the user interface."),
	"type"		: "boolean",
	"defval"	: true,
	"single_line"	: true,
    ],
    "Prq"	: $[
	// label for 'Prq' pattern key
	"label"		: _("Packages"),
	// help text for 'Prq' pattern key
	"help"		: _("List of packages to install."),
	"type"		: "package-list",
	"defval"	: [],
    ],
    "Prc"	: $[
	// label for 'Prc' pattern key
	"label"		: _("Recommended packages"),
	// help text for 'Prc' pattern key
	"help"		: _("These packages are installed by default but can be removed without complaint."),
	"type"		: "package-list",
	"defval"	: [],
    ],
    "Psg"	: $[
	// label for 'Prs' pattern key
	"label"		: _("Suggested packages"),
	// help text for 'Prs' pattern key
	"help"		: _("These are just hints for an application and not handled during dependency resolution."),
	"type"		: "package-list",
	"defval"	: [],
    ],
    "Ico"	: $[
	// label for 'Ico' pattern key
	"label"		: _("Icon filename"),
	// help text for 'Ico' pattern key
	"help"		: _("If unspecified, the pattern name is used 
 instead (with blanks in the name replaced by underscores). If the filename does not include a .png or .jpg extension, .png is appended. If no path is specified, icons are searched for in the theme icon path (first /usr/share/YaST2/theme/current/icons/32x32/apps/ then /usr/share/YaST2/theme/current/icons/48x48/apps/). Absolute and relative paths (to the theme path /usr/share/YaST2/theme/current/) are allowed."),
	"type"		: "file-name",
	"defval"	: "",
	"single_line"	: true,
    ],
    "Ord"	: $[
	// label for 'Ord' pattern key
	"label"		: _("Pattern Order"),
	// help text for 'Ord' pattern key
	"help"		: _("This three-digit integer value defines the order of the pattern when listing multiple patterns in the user interface."),
	"defval"	: "",
	"single_line"	: true,
	"type"		: "integer",
	"range"		: [ 100, 9999 ],
    ],
    "Req"	: $[
	// label for 'Req' pattern key
	"label"		: _("Required patterns"),
	// help text for 'Req' pattern key
	"help"		: _("Patterns that need to be installed together with this pattern."),
	"defval"	: "",
	"type"		: "pattern-list",
    ],
    "Prv"	: $[
	// label for 'Prv' pattern key
	"label"		: _("Provided patterns"),
	// help text for 'Prv' pattern key
	"help"		: _("Capabilities this pattern provides. They can be used to match <b>REQUIRES</b> from others. Every resolvable has a provide by default--its own name and edition. For example, package <i>bar-1.42-1</i> provides the capability <tt>bar = 1.42-1</tt>."),
	"defval"	: "",
	"type"		: "pattern-list",
    ],
    "Con"	: $[
	// label for 'Con' pattern key
	"label"		: _("Conflicting patterns"),
	// help text for 'Con' pattern key
	"help"		: _("This pattern cannot be installed if the specified resolvable or one that provides the capability is installed."),
	"defval"	: "",
	"type"		: "pattern-list",
    ],
    "Obs"	: $[
	// label for 'Obs' pattern key
	"label"		: _("Patterns made obsolete"),
	// help text for 'Obs' pattern key
	"help"		: _("When this pattern is installed, it uninstalls any 
other patterns marked as obsolete here."),
	"defval"	: "",
	"type"		: "pattern-list",
    ],
    "Rec"	: $[
	// label for 'Rec' pattern key
	"label"		: _("Recommended patterns"),
	// help text for 'Rec' pattern key
	"help"		: _("A weak version of REQUIRES. If recommended patterns cannot be installed, no error is shown."),
	"defval"	: "",
	"type"		: "pattern-list",
    ],
    "Sup"	: $[
	// label for 'Sup' pattern key
	"label"		: _("Supplemented patterns"),
	// help text for 'Sup' pattern key
	"help"		: _("A reverse <b>Rec</b>. This pattern is installed if the specified capability is provided by an installed resolvable. The dependency resolver installs it. Uninstalling it is silently accepted."),
	"defval"	: "",
	"type"		: "pattern-list",
    ],
    "Sug"	: $[
	// label for 'Sug' pattern key
	"label"		: _("Suggested patterns"),
	// help text for 'Sug' pattern key
	"help"		: _("These are just hints for an application and not handled during dependency resolution."),
	"defval"	: "",
	"type"		: "pattern-list",
    ],
    "Fre"	: $[
	// label for 'Fre' pattern key
	"label"		: _("Freshen"),
	// help text for 'Fre' pattern key
	"help"		: _("The current pattern is only considered for installation if the pattern specified here is installed."),
	"defval"	: "",
	"type"		: "pattern-list",
    ],
    // TODO during editing, remove from Prc and Prs packages contained in Prq
    // TODO add some key for sorting, so output file is readable


    "Ext"	: $[
	// label for 'Ext' pattern key
	"label"		: _("Extends"),
	"defval"	: "",
	"type"		: "pattern-list",
    ],
    "Inc"	: $[
	// label for 'Inc' pattern key
	"label"		: _("Includes"),
	"defval"	: "",
	"type"		: "pattern-list",
    ],
    "Enh"	: $[
	// label for 'Exnh pattern key
	"label"		: _("Enhanced patterns"),
	"defval"	: "",
	"type"		: "pattern-list",
    ],
    "Pcn"	: $[
	// label for 'Pcn' pattern key
	"label"		: _("Conflicting packages"),
	"type"		: "package-list",
	"defval"	: [],
    ],
    "Pob"	: $[
	// label for 'Pob' pattern key
	"label"		: _("Obsolete packages"),
	"type"		: "package-list",
	"defval"	: [],
    ],
    "Pfr"	: $[
	// label for 'Pfr' pattern key
	"label"		: _("Freshened packages"),
	"type"		: "package-list",
	"defval"	: [],
    ],
    "Psp"	: $[
	// label for 'Psp' pattern key
	"label"		: _("Supplemented packages"),
	"type"		: "package-list",
	"defval"	: [],
    ],
    "Pen"	: $[
	// label for 'Pen' pattern key
	"label"		: _("Enhanced packages"),
	"type"		: "package-list",
	"defval"	: [],
    ],
 ];

// description of keys in package description files
global map<string,map> description_descr	= $[
    "Pkg"	: $[
	// label for 'Pkg' key
	"label"		: _("Package"),
    ],
    "Des"	: $[
	// label for 'Des' key
	"label"		: _("Description"),
	// help text for 'Des' key
	"help"		: _("Multiple line package description."),
	"type"		: "multiline",
	"defval"	: "-",
    ],
    "Sum"	: $[
	// label for 'Sum' key
	"label"		: _("Summary"),
	// help text for 'Sum' key
	"help"		: _("The package summary (label), a one line description of the package."),
	"single_line"	: true,
	"defval"	: "-",
    ],
    "Ins"	: $[
	// label for 'Ins' key
	"label"		: _("Installation Notification"),
	// help text for 'Ins' key
	"help"		: _("An informal message shown to the user if the package is selected, such as a test version warning or a commercial license."),
	"type"		: "multiline",
    ],
    "Del"	: $[
	// label for 'Del' key
	"label"		: _("Deletion Notification"),
	// help text for 'Del' key
	"help"		: _("An informal message shown to the user if the package is selected for deletion, such as a warning that the system is unusable without the package."),
	"type"		: "multiline",
    ],
    "Eul"	: $[
	// label for 'Eul' key
	"label"		: _("EULA"),
	// help text for 'Eul' key
	"help"		: _("Text of the EULA. This text is displayed before the package installation. If the user does not accept the EULA, the package is not installed."),
	"type"		: "multiline",
    ],
];

// script used for signing rpm's
string expect_script =
"#!/usr/bin/expect --
exp_internal 0

set stat 0
foreach rpm $argv {
    spawn -noecho rpm --delsign $rpm
    expect {
	eof {}
    }
    spawn -noecho rpm --define \"_signature gpg\" --define \"_gpg_name %1\" --define \"_gpgbin /usr/bin/gpg\" --resign $rpm
    expect \"pass phrase:\" {send \"%2\r\"}
    expect {
	\"is good.\" {send \"\n\"}
	eof {}
    }
    wait
    spawn -noecho rpm --define \"_signature gpg\" --define \"_gpg_name %1\" --define \"_gpgbin /usr/bin/gpg\" --checksig $rpm
    expect {
	-re \": .*(gpg|pgp).*OK\" {continue;}
	eof      {set stat 1;}
    }
}
exit $stat";

// just key:value mapping based on content list
global map<string,string> content_map	= $[];

// info for product.xml
global map<string,map> product_info_descr	= $[
    "requires"		: $[
	    "key"	: "requires",
	    // label of key
	    "label"	: _("Products that must be installed"),
	    // help text for 'REQUIRES' key
	    "help"	: _("<p>Resolvables that must be installed on the system to meet the needs of this product.</p>"),
	    "type"	: "dependency",
    ],
    "provides"		: $[
	    "key"	: "provides",
	    // label of PROVIDES key
	    "label"	: _("Provided products"),
	    // help text for 'PROVIDES' key
	    "help"	: _("Capabilities this product provides. They can be used to match <b>requires</b> from others."),
	    "type"	: "dependency",
    ],
    "conflicts"		: $[
	    "key"	: "conflicts",
	    // label of 'CONFLICTS' key
	    "label"	: _("Conflicting products"),
	    // help text for 'CONFLICTS' key
	    "help"	: _("This resolvable cannot be installed if the specified resolvable or one that provides the capability is installed."),
	    "type"	: "dependency",
    ],
    "obsoletes"		: $[
	    "key"	: "obsoletes",
	    // label of 'OBSOLETES' key
	    "label"	: _("Products made obsolete"),
	    // help text for 'OBSOLETES' key
	    "help"	: _("When this resolvable is installed, it uninstalls any other resolvable with a name matching this keyword."),
	    "type"	: "dependency",
    ],
    "recommends"	: $[
	    "key"	: "recommends",
	    // label of 'RECOMMENDS' key
	    "label"	: _("Recommended products"),
	    // help text for 'RECOMMENDS' key
	    "help"	: _("A weak version of <b>requires</b>. An attempt is made to fulfill <b>RECOMMENDS</b>, but they are silently ignored if no match is possible."),
	    "type"	: "dependency",
    ],
    "suggests"		: $[
	    "key"	: "suggests",
	    // label of 'SUGGESTS' key
	    "label"	: _("Suggested products"),
	    // help text for 'SUGGESTS' key
	    "help"	: _("These are just hints for an application and not handled during dependency resolution."),
	    "type"	: "dependency",
    ],
    "release"		: $[
	    "key"	: "release",
	    // table item label
	    "label"	: _("The release number"),
    ],
    "releasenotes"		: $[
	    "key"	: "releasenotes",
	    // table item label
	    "label"	: _("The URL for release notes rpm"),
    ],
    "description"	: $[
	    "key"	: "description",
	    // table item label
	    "label"	: _("Product description"),
    ],
    "patchlevel"	: $[
	    "key"	: "patchlevel",
	    // table item label
	    "label"	: _("Patch level"),
    ],
    "summary"		: $[
	    "key"	: "summary",
	    // table item label
	    "label"	: _("Product summary"),
    ],
    "productline"	: $[
	    "key"	: "productline",
	    // table item label
	    "label"	: _("Product line"),
	    // help text for 'productline' key
	    "help"	: _("A short name of the product which do not change between service packs and versions."),
    ],
    "updaterepokey"	: $[
	    "key"	: "updaterepokey",
	    // table item label
	    "label"	: _("Update repository key"),
    ],
    "media type"	: $[
	    "key"	: "media type",
	    // table item label
	    "label"	: _("Type of media"),
	    // help text for media type
	    "help"	: _("Type of media that will be used for target product. Possible values are: cd, ftp, dvd5, dvd9."),
    ],
    "flavor"	: $[
	    "key"	: "flavor",
	    // table item label
	    "label"	: _("Product flavor"),
	    // help text for media type
	    "help"	: _("Description of the flavor or variant of a product, e.g. DVD, FTP, Live"),
    ],
];

// save the structure of product_info, but not the values
global map<string,map> product_info	= $[];

// the content of .prod file, as read using any_xml agent
global map product_xml	= $[];


/**
 * if we have 'source add-on' to base the new one on
 */
global boolean clone	= false;

/**
 * path to directory with existing product (which is being cloned)
 */
global string import_path	= "";

/**
 * if the descriptions of packages should be generated
 * (false have only sense when cloning where they could be read from
 * description files of cloned product)
 */
global boolean generate_descriptions = false;

/**
 * if final Add-On should be bootable (feature not implemented)
 */
global boolean bootable	= false;

// tmp directory
string tmpdir	= "";

// full paths to media directories (media.n)
list<string> full_media_paths	= [];

// architecture specific directory names of target product
list<string> arch_directories = [];

// full path to descr directory
string full_descr_path	= "";

// full path to data directory
string full_data_path = "";

// current GPG key
//global string gpg_key	= "";

// passphrases to unlock secret key (mapping GPG key:pass)
global map passphrases	= $[];

global list<string> gpg_keys	= [];

// packages from current AddOn available for the pattern
global map<string,list> available_packages = $[];

// mapping of package name to full file name
global map<string,map> package2filename = $[];

// mapping of source package name to full file name
global map<string,map> srcpackage2filename	= $[];

// if we want only to sign existing product (and possibly create iso of it)
global boolean only_sign_product		= false;

// if pattern files should be compressed
global boolean compress_patterns		= false;

// if pattern definitions should be merged into one file TODO
global boolean merge_patterns			= false;

// if package description files should be compressed
global boolean compress_package_descriptions	= false;

// if we should generate -release package containing .prod file
global boolean generate_release_package		= true;

/**
 * Data was modified?
 */
global boolean modified = false;

boolean gzip_is_installed	= nil;

boolean gzip_installed () {
    if (gzip_is_installed == nil)
	gzip_is_installed = Package::Installed ("gzip");
    return gzip_is_installed;
}

map lang_codes = $[
    "languages"		: nil,
    "with_country"	: nil,
];

/**
 * argument for any_xml agent: key indicating content of element without
 * attributes
 */
global string content_key	= "__yast_content__";

/**
 * Data was modified?
 * @return true if modified
 */
global boolean Modified() {
    y2debug("modified=%1",modified);
    return modified;
}


/**
 * import the data from given xml file
 * @param path to .prod file
 * @ret map of imported data
 */
global map<string,any> ReadProductXML (string prod_file_path) {

    map<string,any> ret	= $[];
    if (!FileUtils::Exists (prod_file_path))
    {
	y2warning ("no such file %1", prod_file_path);
	return ret;
    }

    // read rest of config.xml using more generic agent
    map anyxml		= (map) SCR::Read (.anyxml, $[
	"file"	: prod_file_path,
	"args"	: $[
	    "ForceArray"	: 1,
            "KeepRoot"		: 1,
	    "KeyAttr"		: [],
	    "ForceContent"	: 1,
	    "ContentKey"	: content_key,
	]
    ]);
    ret		= (map<string,any>) anyxml;
    return ret;
}

/**
 * Get the map describing product.xml and produce better readable YCP map
 * @param xml map as read from xml file (from ReadProductXML)
 * @param if the values in new ProductInfo map should be merged with current one
 * (only changes are written when saving project, this means 'apply changes')
 */
global map<string,map> GetProductInfo (map xml, boolean merge_with_current) {

    // (because it is 'merge_with_current', product_info can
    // be used as global variable, reflecting current state)
    map<string,map> retmap	=
	merge_with_current ? product_info : product_info_descr;
    map prod_map	= $[];
    if (size (xml["productdefinition",0,"products"]:[]) > 0)
    {
	prod_map	= xml["productdefinition",0,"products",0]:$[];
    }
    prod_map		= xml["product",0]:$[]; // maso, ze?

    // only simple values are supported here, something nested
    // deeper (e.g. linguas) will not work
    foreach (string key, map desc, retmap, {
	if (haskey (prod_map, key))
	{
	    string val	= prod_map[key,0,content_key]:"";
	    if (val != "")
	    {
		if (merge_with_current)
		{
		    // set the new value only when there is nothing
		    // present in product_info[key]:
		    // in case we are editing existing add-on product
		    // configuration, there can be some modifications
		    // saved, and they are preferred
		    if (retmap[key,"value"]:"" == "")
			retmap[key,"value"]	= val;
		    else
			// manual modifications present -> generate
			// this is used when product xml was read from rpm
			generate_release_package	= true;
		}
		else
		    retmap[key,"value"]       = val;
	    }
	}
    });
    // ok, let's try to read at least release notes url
    foreach (map url, prod_map["urls",0,"url"]:[], {
	if (url["name"]:"" == "releasenotes")
	{
	    if (!merge_with_current || retmap["releasenotes","value"]:"" == "")
		retmap["releasenotes","value"]	= url[content_key]:"";
	}
    });
    // read the product dependencies which may be in mediasets section
    map mediamap = xml["productdefinition",0,"mediasets",0,"media",0]:$[];
    foreach (map dep, mediamap["productdependency"]:[], {
	string key	= dep["relationship"]:"";
	if (retmap[key,"value"]:[] == [])
	    retmap[key,"value"]	= [];
	retmap[key,"value"]	= add (retmap[key,"value"]:[],
	    remove (dep, "relationship"));
    });
    y2milestone ("product_info: %1", retmap);
    return retmap;
}

/**
 * Take list of content-file data and update global content_map.
 * If argument is empty, global 'content' list is used as an input.
 */
global map<string,string> UpdateContentMap (list<map> content_list) {

    if (content_list == nil || content_list == [])
	content_list	= content;
    foreach (map entry, content_list, {
	if (entry["value"]:"" != "")
	    content_map[entry["key"]:""] = entry["value"]:"";
    });
    return content_map;
}


// return list of language codes, optionally together with country code
global list<string> GetLangCodes (boolean country) {

    string key	= country ? "with_country" : "languages";
    string cut	= country ? "cut -f 1 -d . | cut -f 1 -d @" : "cut -f 1 -d _";
    if (lang_codes[key]:nil == nil)
    {
	map out = (map) SCR::Execute (.target.bash_output, "locale -a | " + cut,
	    $[ "LANG" : "C"]);
	lang_codes[key] =
	    filter (string l, toset (splitstring (out["stdout"]:"", "\n")), {
		return (l != "" && l != "C" && l != "POSIX");
	    });
    }
    return lang_codes[key]:[];
}

// if file is true, it creates the file name for the pattern, otherwise
// the Pat value
global string CreatePatternFullName (map pattern, boolean file) {
    return sformat ("%1%5%2%5%3%6%4%7",
	pattern["name"]:"",
        pattern["version"]:"",
        pattern["release"]:"",
        pattern["arch"]:"",
	file ? "-" : " ",
	file ? "." : " ",
	file ? ".pat" : ""
    );
}

// read the list of available secret keys
list<string> read_secret_keys () {

    map out = (map) SCR::Execute (.target.bash_output, "gpg --list-secret-keys|grep '^sec'|sed -e 's/.*\\///;s/ .*//g;'");
    return filter (string k, splitstring(out["stdout"]:"", "\n"),``(k!=""));
}


/**
 * Generate the key pair
 */
global string GenerateGPGKey (map<string,string> data) {

    string data_cont	= sformat ("Key-Type: %1\n", data["Key-Type"]:"");
    data = remove (data, "Key-Type");
    foreach (string key, string val, data, {
	if (val != "")
	    data_cont	= data_cont + sformat ("%1: %2\n", key, val);
    });

    // save the needed data to file
    string data_path	= tmpdir + "/gen-key-data";
    SCR::Write (.target.string, data_path, data_cont);

    map out	= (map) SCR::Execute (.target.bash_output,
	"gpg --batch --gen-key " + data_path);
    if (out["exit"]:0 != 0)
    {
	y2warning ("error calling gpg: %1", out);
	return "";
    }

    SCR::Execute (.target.remove, data_path);

    gpg_keys	= read_secret_keys ();
    return gpg_keys[size (gpg_keys) - 1]:"";
}

/**
 * Initialize the settings for add-on-creator
 * @return true on success
 */
global boolean Read() {

    if (!PackageSystem::CheckAndInstallPackagesInteractive (["inst-source-utils"]))
	return false;

    gpg_keys	= read_secret_keys ();

    map out = (map) SCR::Execute (.target.bash_output, "/usr/bin/id --user");
    if (out["stdout"]:"" != "0\n" && out["stdout"]:"" != "")
    {
	out	= (map) SCR::Execute (.target.bash_output, "echo $HOME");
	string home	= getenv ("HOME");
	if (home != "" && home != nil)
	    add_on_products_file	= home + "/add_on_products.ycp";
    }

    // Read the info of configured AddOns
    if (FileUtils::Exists (add_on_products_file))
    {
	list<map> all_products	= (list<map>)
	    SCR::Read (.target.ycp, add_on_products_file);
	if (all_products != nil)
	    add_on_products	= all_products;
    }
    else
    {
	current_product["gpg_key"]	= gpg_keys[0]:"";
    }
    // fill uninitialized values in content descriptions
    integer i	= 0;

    foreach (string key, map entry, content_descr, {
	if (entry["allowed_values"]:nil == nil)
	{
	    // TODO add a handlers for filling the values
	    if (key == "LANGUAGE")
		content_descr[key,"allowed_values"] = GetLangCodes (true);
	    else
		content_descr[key,"allowed_values"] = [];
	}
	if (key == "DEFAULTBASE")
	    content_descr[key,"value"]	= Arch::architecture ();
	string defval = (string)SCR::Read (add(.sysconfig.add-on-creator, key));
	if (defval != nil && defval != "")
	{
	    y2milestone ("using default value for %1: %2", key, defval);
	    content_descr[key,"value"]	= defval;
	}
	i	= i + 1;
    });

    tmpdir	= Directory::tmpdir;

    if (SCR::Read (.sysconfig.add-on-creator.COMPRESS_PATTERNS) == "yes")
	compress_patterns	= true;

    if (SCR::Read (.sysconfig.add-on-creator.COMPRESS_PACKAGE_DESCRIPTIONS)
	== "yes")
	compress_package_descriptions	= true;

    if (product_xml == $[])
	// read the template file
	product_xml	= ReadProductXML (
	    Directory::datadir + "/add-on-creator/template.prod");

    // fill the inital values
    product_info	= product_info_descr;
    return true;
}

// read the content file given by file name
global list<map> ReadContentFile (string file_path) {

    list<map> ret	= [];

    y2milestone ("Importing content file '%1'", file_path);

    SCR::RegisterAgent (.content, `ag_ini (`IniAgent (file_path,
	$[
	    "options" : ["global_values", "flat"],
	    "comments" : [ "^#.*", "^[ \t]*$", ],
	    "params" : [ $[
		"match" : [
		    "^[ \t]*([a-zA-Z0-9_\.]+)[ \t]+(.*[^ \t]|)[ \t]*$",
		    "%s %s",
		]
	    ] ]
	]
    )));

    list<string> keys	= (list<string>) SCR::Dir (.content);
    foreach (string key, keys, {
	string val = (string) SCR::Read (add (.content, key));
	if (val == nil) return;
	map entry	= content_descr[key]:$[];
	if (entry == $[] && issubstring (key, "."))
	{
	    entry	=
		content_specials[substring (key,0,findfirstof (key,"."))]:$[];
	}
	if (entry != $[])
	{
	    entry["key"]	= key;
	    entry["value"]	= val;
	    ret	= add (ret, entry);
	    content_map[key]	= val;
	}
    });
    SCR::UnregisterAgent (.content);

    // + fill the rest
    foreach (string key, map entry, content_descr, {
	if (!contains (keys, key))
	    ret = add (ret, entry);
    });

    return ret;
}

/**
 * Take a path to compressed file as argument and return path to uncompressed one\
 */
string uncompress_file (string file_path) {

    string ret	= file_path;
    if (substring (file_path, size (file_path) - 3, 3) == ".gz" &&
	gzip_installed ())
    {
	list full	= splitstring (file_path, "/");
	string file	= full[size (full) - 1]:"";
	if (!FileUtils::Exists (tmpdir + "/" + file))
	    SCR::Execute (.target.bash, sformat ("cp %1 %2/", file_path, tmpdir));
	map o = (map)SCR::Execute (.target.bash_output, sformat ("cd %1; gunzip %2", tmpdir, file));
	if (o["exit"]:1 == 0)
	    ret = tmpdir + "/" + substring (file, 0, size (file) - 3);
	else
	    y2warning ("gunzip failed with %1 (%2)", o["exit"]:0, o["stderr"]:"");
    }
    return ret;
}

// read the pattern given by file name (obsolete, use ReadPatternsFile instead)
global map ReadPatternFile (string file_path) {

    y2milestone ("Importing pattern '%1'", file_path);
    file_path	= uncompress_file (file_path);

    map ret	= $[];
    map pt	= (map) SCR::Read (.pattern, file_path);

    foreach (string key, any val, (map<string,any>) pt, {
	if (pattern_descr[key,"type"]:"" == "package-list")
	{
	    ret[key]	= splitstring (sformat ("%1", val), "\n");
	    // make the packages included in imported pattern available for UI
	    available_packages["ZZZ_imported"] = union (
		available_packages["ZZZ_imported"]:[], ret[key]:[]);
	}
	else
	    ret[key]	= val;
    });
    foreach (string key, map descr, pattern_descr, {
	if (!haskey (ret, key) && !descr["internal"]:false)
	{
	    y2debug ("adding empty key '%1'...", key);
	    // do not add default values - maybe imported pattern
	    // ignored them intentionally
	    ret[key]	= "";
	}
    });
    return ret;
}

/**
 * read all the patterns defined in given file
 * @return list of pattern maps
 */
global list<map> ReadPatternsFile (string file_path) {

    y2milestone ("Importing pattern '%1'", file_path);
    file_path	= uncompress_file (file_path);

    list<map> retlist	= [];
    list<map> pts	= (list<map>) SCR::Read (.pattern.list, file_path);

    foreach (map pt, pts, {
	map ret	= $[];
	foreach (string key, any val, (map<string,any>) pt, {
	    if (pattern_descr[key,"type"]:"" == "package-list")
	    {
		ret[key]	= splitstring (sformat ("%1", val), "\n");
		// make the packages included in pattern available for UI
		available_packages["ZZZ_imported"] = union (
		    available_packages["ZZZ_imported"]:[], ret[key]:[]);
	    }
	    else
		ret[key]	= val;
	});
	// add empty values for keys not present in imported pattern
	foreach (string key, map descr, pattern_descr, {
	    if (!haskey (ret, key) && !descr["internal"]:false)
	    {
		y2debug ("adding empty key '%1'...", key);
		// do not add default values - maybe imported pattern
		// ignored them intentionally
		ret[key]	= "";
	    }
	});
	if (ret != $[])
	    retlist	= add (retlist, ret);
    });
    return retlist;
}

// read the package description (package.lang) file
global map ReadPackagesFile (string file_path) {

    y2milestone ("Importing package description '%1'", file_path);

    return PackagesDescr::Read (uncompress_file (file_path));
}

/**
 * import the data from existing add-on
 * @param path to existing addon directory
 */
global boolean ImportExistingProduct (string dir_path) {

    content	= ReadContentFile (dir_path + "/content");

    current_product["rpm_path"]	=
	sformat("%1/%2", dir_path, content_map["DATADIR"]:"");

    // - read patterns
    string descr_path = sformat ("%1/%2", dir_path, content_map["DESCRDIR"]:"");

    map out = (map) SCR::Execute (.target.bash_output,
	sformat ("ls -A1 %1/*.pat %1/*.pat.gz 2>/dev/null", descr_path));
    map patterns	= $[];
    foreach (string f, splitstring(out["stdout"]:"", "\n"), {
	if (f == "") return;
	foreach (map pat, ReadPatternsFile (f), {
	    if (pat != $[])
	    {
		list<string> pt	= splitstring (pat["Pat"]:"", " ");
		string name	= pt[0]:"";
		if (name != "")
		{
		    pat["name"]		= name;
		    pat["version"]	= pt[1]:"";
		    pat["release"]	= pt[2]:"";
		    pat["arch"]		= pt[3]:"";
		    patterns[name]	= pat;
		}
	    }
	});
    });
    current_product["patterns"]	= patterns;

    if (!generate_descriptions)
    {
	SCR::Execute (.target.bash, sformat("/bin/rm -f %1/packages*", tmpdir));
	// save packages* files to tmpdir, they will be imported later
	SCR::Execute (.target.bash,
	    sformat ("/bin/cp %1/packages* %2", descr_path, tmpdir));
    }
    string extra	= descr_path + "/EXTRA_PROV";
    if (FileUtils::Exists (extra))
    {
	string cont     = (string) SCR::Read (.target.string, extra);
	if (cont != nil)
	{
	    current_product["extra_prov"]	= cont;
	    current_product["extra_prov_file"]	= extra;
	}
    }

    // read README
    foreach (string readme, ["README", "README.DOS", "LIESMICH","LIESMICH.DOS"],
    {
	string readme_path	= dir_path + "/" + readme;
	if (FileUtils::Exists (readme_path))
	{
	    y2milestone ("Importing readme file '%1'", readme_path);
	    string cont	= (string) SCR::Read(.target.string, readme_path);
	    if (cont != nil)
		current_product["readme_files", readme]	= cont;
	}
    });

    // read the license files
    string license_path	= dir_path + "/media.1/license.zip";
    out	= $[];
    // license.zip is obsolete
    if (FileUtils::Exists (license_path))
    {
	SCR::Execute (.target.bash_output,
	    sformat ("/usr/bin/unzip -o %1 -d %2", license_path, tmpdir));
	out = (map) SCR::Execute (.target.bash_output,
	    sformat ("ls -A1 %1/license*.txt 2>/dev/null", tmpdir));
    }
    else if (FileUtils::Exists (dir_path + "/license.tar.gz"))
    {
	SCR::Execute (.target.bash_output,
	    sformat ("/bin/tar -zxf %1/license.tar.gz -C %2", dir_path,tmpdir));
	out = (map) SCR::Execute (.target.bash_output,
	    sformat ("ls -A1 %1/license*.txt 2>/dev/null", tmpdir));
    }
    else if (FileUtils::IsDirectory (dir_path + "/media.1/license") == true)
    {
	out = (map) SCR::Execute (.target.bash_output,
	    sformat ("ls -A1 %1/media.1/license/license*.txt 2>/dev/null",
	    dir_path));
    }
    // extract license.txt from EULA.txt
    // (no other need to read EULA, it should be just license.txt + packages)
    else if (FileUtils::Exists (dir_path + "/EULA.txt"))
    {
	SCR::Execute (.target.bash,
	    sformat ("/bin/cp %1/EULA.txt %2/license.txt", dir_path, tmpdir));
	out = (map) SCR::Execute (.target.bash_output,
	    sformat ("ls -A1 %1/license*.txt 2>/dev/null", tmpdir));
    }
    if (out != $[])
    {
	foreach (string f, splitstring(out["stdout"]:"", "\n"), {
	    if (f == "") return;
	    string name	= substring (f, findlastof (f, "/") + 1);
	    if (issubstring (name, ".txt"))
		name	= regexpsub (name, "^(.*)\.txt$", "\\1");
	    y2milestone ("Importing license file '%1'", f);
	    string cont	= (string) SCR::Read (.target.string, f);
	    if (cont != nil)
		current_product["license_files", name]	= cont;
	});
    }

    out = (map) SCR::Execute (.target.bash_output,
	sformat ("ls -A1 %1/COPYING* 2>/dev/null", dir_path));
    foreach (string f, splitstring(out["stdout"]:"", "\n"), {
	if (f == "") return;
	string name	= substring (f, findlastof (f, "/") + 1);
	y2milestone ("Importing COPYING file '%1'", f);
	string cont	= (string) SCR::Read (.target.string, f);
	if (cont != nil)
	    current_product["copying_files",name] = cont;
    });

    out = (map) SCR::Execute (.target.bash_output,
	sformat ("ls -A1 %1/COPYRIGHT* 2>/dev/null", dir_path));
    foreach (string f, splitstring(out["stdout"]:"", "\n"), {
	if (f == "") return;
	string name	= substring (f, findlastof (f, "/") + 1);
	y2milestone ("Importing COPYRIGHT file '%1'", f);
	string cont	= (string) SCR::Read (.target.string, f);
	if (cont != nil)
	    current_product["copyright_files",name]	= cont;
    });

    // read the info.txt
    string info_path	= dir_path + "/media.1/info.txt";
    if (FileUtils::Exists (info_path))
    {
	string info	= (string) SCR::Read (.target.string, info_path);
	if (info == nil) info = "";
	current_product["info"]	= info;
    }

    // read the content of media.n dirs
    out = (map) SCR::Execute (.target.bash_output,
	sformat ("ls -A1 -d %1/media.* 2>/dev/null", dir_path));
    if (out["stdout"]:"" != "")
    {
	list<string> products_files	= [];
	list<string> media_files	= [];
	list<string> patches_files	= [];
	foreach (string d, splitstring(out["stdout"]:"", "\n"), {
	    if (d == "") return;
	    string products_path	= d + "/products";
	    if (FileUtils::Exists (products_path))
	    {
		y2milestone ("Importing products file '%1'", products_path);
		products_files	= add (products_files,
		    (string) SCR::Read (.target.string, products_path));
	    }
	    else products_files  = add (products_files, "");
	    string media_path	= d + "/media";
	    if (FileUtils::Exists (media_path))
	    {
		y2milestone ("Importing media file '%1'", media_path);
		media_files	= add (media_files,
		    (string) SCR::Read (.target.string, media_path));
	    }
	    else media_files	= add (media_files, "");
	    string patches_path	= d + "/patches";
	    if (FileUtils::Exists (patches_path))
	    {
		y2milestone ("Importing patches file '%1'", patches_path);
		patches_files	= add (patches_files,
		    (string) SCR::Read (.target.string, patches_path));
	    }
	    else patches_files	= add (patches_files, "");
	});
	current_product["products_files"]	= products_files;
	current_product["media_files"]		= media_files;
	current_product["patches_files"]	= patches_files;
    }

    string desc_path	= dir_path + "/installation.xml";
    if (FileUtils::Exists (desc_path))
    {
	current_product["workflow_path"]	= desc_path;
    }

    string workflow_packages_path	= dir_path + "/y2update.tgz";
    if (FileUtils::Exists (workflow_packages_path))
    {
	current_product["y2update_path"]	= workflow_packages_path;
    }

    return true;
}

/**
 * converts the output of find command (=possibly big string with each file on one line),
 * to the list of smaller strings (<128kB), each with space separated file names
 * @param stdout output of find command
 */
list<string> create_argument_lists (string stdout) {

    list<string> ret	= [];
    if (stdout == nil || stdout == "") return ret;
    // approximately maximum size of parameters list passed to rpm
    integer kbytes		= 120;
    // looks like pre-sorting helps to fasten rpm call
    list<string> found	= sort (splitstring (stdout, "\n"));
    if (size (stdout)/1024 <= kbytes)
	ret	= [ mergestring (found, " ") ];
    else
    {
	string line	= "";
	foreach (string file, found, {
	    line	= line + file + " ";
	    if (size (line) / 1024 > kbytes)
	    {
		ret	= add (ret, line);
		line	= "";
	    }
	});
	if (size (line) / 1024 <= kbytes)
	    ret	= add (ret, line);
    }
    return ret;
}

// this is used during the workflow, not in the write!
// TODO change name...
global void FillContentDefaults () {

    // AddOnCreator Build dialog caption
    string caption	= _("Generating Product Data");

    list stages	= [
	    // Progress stage
	    _("Find package directories"),
    ];
    list steps	= [
	    // Progress step
	    _("Looking for package directories..."),
    ];
    if (!clone)
    {
	stages	= union (stages, [
	    // Progress stage
	    _("Check package architectures"),
	    // Progress stage
	    _("Generate content file defaults"),
	]);
	steps	= union (steps, [
	    // Progress step
	    _("Checking package architectures..."),
	    // Progress step
	    _("Generating content file defaults..."),
	]);
    }
    stages	= union (stages, [
	    // Progress stage
	    _("Generate package descriptions"),
    ]);
    steps	= union (steps, [
	    // Progress step
	    _("Generate package descriptions"),
    ]);

    Progress::New (caption, " ", size (stages),
	(list<string>) stages, (list<string>) steps,
	// help text
	_("<b>Wait while generating data for add-on...</b><br/>
"));

    Progress::NextStage();
    map<string,string> arch_map	= $[];
    string rpm_path	= current_product["rpm_path"]:"";

    // 1. find the used architectures
    string cmd	= sformat ("cd %1; find -maxdepth 1 -type d", rpm_path);
    map out	= $[];
    if (rpm_path != "")
	out	= (map) SCR::Execute (.target.bash_output, cmd);

    arch_directories	= [];
    foreach(string d, splitstring(out["stdout"]:"", "\n"), {
	list splitdir = splitstring (d, "/");
	string arch_dir	= splitdir[1]:"";
	if (contains (allowed_archs, arch_dir))
	{
	    arch_directories	= add (arch_directories, arch_dir);
	}
    });
    Progress::NextStage();

    // name of -release packages, if found
    list<string> release_packages			= [];

    if (!clone)
    {
	// 2. get the list of architectures from RPM's
	if (rpm_path != "")
	    out	= (map) SCR::Execute (.target.bash_output,
		sformat ("find %1 -name '*.rpm'", rpm_path));
	y2milestone ("asking the RPM's for ARCH and NAME...");
	// for which architectures are the packages built
	map<string,any> package_architectures	= $[];
	foreach (string f, splitstring (out["stdout"]:"", "\n"), {
	    if (f == "") return;
	    out = (map) SCR::Execute (.target.bash_output,
	        sformat ("rpm -q -p %1 --qf \"%%{ARCH}\n%%{NAME}\n%%|SOURCERPM?{bin}:{src}|\"",f));
	    list lines  = splitstring (out["stdout"]:"", "\n");
	    string arch = lines[0]:"";
	    string name = lines[1]:"";
	    string sourcerpm	= lines[2]:"";
	    // 'arch' is directory where to put final package
	    if (sourcerpm == "src")
		arch	= "src";
	    if (name != "" && arch != "")
	    {
		available_packages[arch] = add (
		    available_packages[arch]:[], name);
		if (!haskey (package2filename, arch))
		    package2filename[arch]	= $[];
		if (!haskey (srcpackage2filename, arch))
		    srcpackage2filename[arch]	= $[];
		if (arch != "src")
		{
		    package2filename[arch,name]	= f;
		    package_architectures[arch]	= 1;
		}
		else
		    srcpackage2filename[arch,name]      = f;
	    }
	    if (name != "" && size (name) > 8 && issubstring (name, "-release"))
	    {
		y2milestone ("release package found: %1, %2", name, f);
		release_packages	= add (release_packages, f);
	    }
	});
	y2milestone ("... done");
	Progress::NextStage();

	// 3. add 'guessed' ARCH.base values to the content file
	if (content_map != $[] || arch_map != $[])
	{
	    content	= []; // new proposal
	    foreach (string key, map entry, content_descr, {
		if (content_map[key]:"" != "")
		    entry["value"]	= content_map[key]:"";
		if (key == "BASEARCHS")
		{
		    string archs	= mergestring (arch_directories, " ");
		    if (arch_directories == [])
			archs	= mergestring ((list<string>) maplist (
			    string a, any v, package_architectures,``(a)), " "
			);
		    entry["value"]	= archs;
		}
		if (key == "DISTRIBUTION" && content_map[key]:"" == "")
		{
		    entry["value"]	=
			content_map["NAME"]:"" + " "+ content_map["VERSION"]:"";
		}
		content	= add (content, entry);
	    });
	}
	string required_rpm_path = current_product["required_rpm_path"]:"";
	// 4. read the list of packages, not present on AddOn
	if (required_rpm_path != "" && required_rpm_path != rpm_path)
	{
	    out	= (map) SCR::Execute (.target.bash_output,
		sformat ("cd %1; find -name '*.rpm'", required_rpm_path));
	    y2milestone ("asking the RPM's for NAME...");
	    list<string> inputs		= create_argument_lists (out["stdout"]:"");
	    string output	= "";
	    foreach (string input, inputs, {
		string cmd	= sformat ("cd %1; rpm --qf \"%%{NAME}\n\" -qp %2",
		    required_rpm_path, input);
		out	= (map) SCR::Execute (.target.bash_output, cmd);
		output	= output + out["stdout"]:"" + "\n";
	    });
	    // remove empty strings and duplicates
	    available_packages["ZZZ_required"] = toset (filter (
		string name, splitstring (output, "\n"), ``(name != "")));
	    y2milestone ("... done");
	}
	Progress::NextStage();
    }
    // we want to find and read release packages for cloned product
    else {
	out	= (map) SCR::Execute (.target.bash_output,
	    sformat ("find %1 -name '*-release*'", rpm_path));
	foreach (string f, splitstring (out["stdout"]:"", "\n"), {
	    if (f == "") return;
	    out = (map) SCR::Execute (.target.bash_output,
	        sformat ("rpm -q -p %1 --qf \"%%{NAME}\n%%|SOURCERPM?{bin}:{src}|\"",f));
	    list lines		= splitstring (out["stdout"]:"", "\n");
	    string name		= lines[0]:"";
	    string sourcerpm	= lines[1]:"";
	    if (sourcerpm != "src" && name != "" &&
		size (name) > 8 && issubstring (name, "-release"))
	    {
		y2milestone ("release package found: %1, %2", name, f);
		release_packages	= add (release_packages, f);
	    }
	});
    }
    if (rpm_path == "")
    {
	Progress::Finish ();
	return;
    }
    string reldir   = tmpdir + "/release";
    if (release_packages != [])
    {
	// when release package is present, do not offer to change it
	generate_release_package	= false;
    }
    list requireslist	= [];

    // read the product info contained in release package
    foreach (string release_package, release_packages, {
	// use 'reldir' only for one package
	SCR::Execute (.target.bash, "rm -rf " + reldir);
	SCR::Execute (.target.mkdir, reldir);
	SCR::Execute (.target.bash,
	    sformat ("cp %1 %2", release_package, reldir));
	SCR::Execute (.target.bash,
	    sformat ("cd %1; rpm2cpio %2 | cpio -imud 2>/dev/null", reldir,
	    substring (release_package, findlastof(release_package, "/")+1))
	);
	out = (map) SCR::Execute (.target.bash_output, sformat (
	    "ls -A1 %1/release/etc/products.d/*.prod 2>/dev/null", tmpdir));
	list out_l	= splitstring (out["stdout"]:"", "\n");
	string prod_file	= out_l[0]:""; // we care about the first one
	if (prod_file == "")
	{
	    // release package does not contain .prod, it may be flavor package:
	    // check for product dependencies
	    // rpm -qp --requires `path to rpm` | grep product
	    out = (map) SCR::Execute (.target.bash_output, sformat (
		"rpm -qp --requires %1 | grep \"product(.*)\"",
		release_package));
	    // line is e.g. 'product(SUSE_SLED-SP3-dvd5) = 11-2', which means
	    // name-SPpatchlevel-flavor flag version-release, where
	    // only name, flag and version are mandatory
	    string re	= "^product[\(]+([^-]*)[-]*(SP[0-9]*)*[-]*([^-]*)[\)]+[ \t]*([<=>]+)[ \t]*([0-9]*)[-]*(.*)$";
	    foreach (string prodline, splitstring (out["stdout"]:"", "\n"), {
		if (prodline == "") return;
		list tokens	= regexptokenize (prodline, re);
		// = ["SUSE_SLED","SP3","dvd5","=","11","2"] for above example
		string flag	= "EQ";
		if (tokens[3]:"" == ">")
		    flag	= "GE";
		else if (tokens[3]:"" == "<")
		    flag	= "LT";
		map requiremap	= $[
		    "name"	: tokens[0]:"",
		    "version"	: tokens[4]:"",
		    "flag"	: flag
		];
		if (tokens[1]:"" != "")
		    requiremap["patchlevel"]	= substring (tokens[1]:"", 2);
		if (tokens[2]:"" != "")
		    requiremap["flavor"]	= tokens[2]:"";
		if (tokens[5]:"" != "")
		    requiremap["release"]	= tokens[5]:"";
		y2milestone ("requiremap: %1", requiremap);
		requireslist	= add (requireslist, requiremap);
	    });
	    return;
	}

	y2milestone ("reading product info from %1", prod_file);
	// read the prod file info and add it into the template
	product_xml	= ReadProductXML (prod_file);

	// translate product_xml map into product_info
	product_info	= GetProductInfo (product_xml, true);
    });
    if (requireslist != [])
    {
	product_info["requires"]	= product_info_descr["requires"]:$[];
	product_info["requires","value"]= requireslist;
    }

    // generate tmp package descriptions...
    if ((generate_descriptions || !clone) &&
	FileUtils::Exists ("/usr/bin/create_package_descr"))
    {
	y2milestone ("creating packages descriptions...");
	cmd	= sformat("/usr/bin/create_package_descr -d %1 -C -F -o %2",
	    rpm_path, tmpdir);
	SCR::Execute (.target.bash, cmd, $["LANG":"C"]);
	y2milestone ("... done");
    }
    out = (map) SCR::Execute (.target.bash_output,
	sformat ("ls -A1 %1/packages.* 2>/dev/null", tmpdir));
    string lang	= "en";
    map packages_descr	= current_product["packages_descr"]:$[];
    foreach (string file, splitstring (out["stdout"]:"", "\n"), {
	list f	= splitstring (file, ".");
	lang	= f[size(f)-1]:"en";
	if (lang == "gz") // fortunatelly, there is no 'gz' locale...
	{
	    if (size (f) > 2)
		lang	= f[size(f)-2]:"en";
	    else return;
	}
	if (file == "" || lang == "DU" || lang == "FL") return;
	if (packages_descr[lang]:$[] == $[])
	{
	    packages_descr[lang]    = ReadPackagesFile (file);
	    return;
	}
	// now, we need to merge old data from packages_descr with currently
	// generated ones (TODO this works only for packages.en)
	foreach (string p, map d, (map<string,map>) ReadPackagesFile (file), {
	    if (!haskey (packages_descr[lang]:$[], p))
	    {
		y2debug ("new package %1", d);
		packages_descr[lang,p]	= d;
	    }
	});
    });
    current_product["packages_descr"]	= packages_descr;

    // we need the list of packages (for patterns), but asking
    // rpm would be slow, so let's get it from (already existing) descriptions
    if (clone)
    {
	y2milestone ("gathering available_packages from descriptions...");
	foreach (string p, map d, (map<string,map>) packages_descr[lang]:$[], {
	    if (p == "___global___") return;
	    list pkg_list	= splitstring (d["Pkg"]:"", " ");
	    string arch		= pkg_list[size (pkg_list) -1 ]:"noarch";
	    available_packages[arch] = add (available_packages[arch]:[], p);
	});
    }
    Progress::NextStage();
}

/**
 * Write the content file
 * @return success
 */
global boolean WriteContentFile (string base_path, list<map> content_data) {

    if (!FileUtils::Exists (base_path)) return false;

    string file	= "";
    foreach (map entry, content_data, {
	if (entry["value"]:"" != "")
	{
	    if (entry["key"]:"" != "CONTENTSTYLE")
	    {
		file = file +
		    sformat ("%1 %2\n",entry["key"]:"",entry["value"]:"");
	    }
	    content_map[entry["key"]:""] = entry["value"]:"";
	}
    });
    // CONTENTSTYLE must be first key...
    file = sformat ("CONTENTSTYLE %1\n", content_map["CONTENTSTYLE"]:"11")+file;

    return SCR::Write (.target.string, base_path + "/content", file);
}

/**
 * Write the readme/COPYING/COPYRIGHT... files in base_path
 * @return success
 */
global boolean WriteStringFiles (string base_path, map<string,string> files) {

    if (!FileUtils::Exists (base_path)) return false;

    boolean ret	= true;
    foreach (string file, string cont, files, {
	if (cont != "")
	    ret = ret && SCR::Write(.target.string, base_path +"/"+ file, cont);
    });
    return ret;
}

/**
 * generate the paths of media, data and description dirs
 */
global void GenerateDirectories (string base_path) {

    integer i = 1;
    integer no_of_medias	= 1;
    while (i <= no_of_medias)
    {
	string media_path	= sformat ("%1/media.%2", base_path, i);
	full_media_paths	= add (full_media_paths, media_path);
	i = i + 1;
    }
    full_data_path =sformat("%1/%2", base_path,content_map["DATADIR"]:"");
    full_descr_path = sformat ("%1/%2", base_path, content_map["DESCRDIR"]:"");
}

/**
 * Create the directory structure of the Add-On
 * @return success
 */
global boolean CreateAddOnStructure (string base_path) {

    if (!FileUtils::Exists (base_path)) return false;

    GenerateDirectories (base_path);
    // create the media's directories
    foreach (string dir, full_media_paths, {
	SCR::Execute (.target.mkdir, dir);
    });

    // create the data dir
    if (content_map["DATADIR"]:"" == "")
    {
	y2error ("DATADIR is : %1", content_map["DATADIR"]:"");
	return false;
    }

    SCR::Execute (.target.mkdir, full_data_path);

    // create the dirs for packages
    if (arch_directories == [])
    {
	foreach (string arch_dir, list pa, available_packages, {
	    if (arch_dir != "ZZZ_imported" && arch_dir != "ZZZ_required")
		SCR::Execute (.target.mkdir, full_data_path + "/" + arch_dir);
	});
    }

    SCR::Execute (.target.mkdir, full_descr_path);

    return true;
}

/**
 * Generate the package descriptions using create_package_descr
 */
global boolean GeneratePackageDescriptions () {

    if (!FileUtils::Exists ("/usr/bin/create_package_descr")) return false;

    string command = sformat ("/usr/bin/create_package_descr -d %1 -C -F -o %2",
	full_data_path, full_descr_path);
    SCR::Execute (.target.bash_output, command, $["LANG":"C"]);
    return true;

}

/**
 * Write the package descriptions edited by user
 * @path descr_path full path to directory with package descriptions (DESCRDIR)
 * @path map with package descriptions
 */
global boolean WritePackageDescriptions (string descr_path, map descr) {

    if (!FileUtils::Exists (descr_path)) return false;

    y2milestone ("writing package description files...");

    boolean ret	= true;
    if (descr == $[]) return ret;
    foreach (string lang, map data, (map<string,map>)descr, {
	string file_path	= descr_path + "/packages." + lang;
	ret	= ret && PackagesDescr::Write (file_path,(map<string,any>)data);
	y2debug ("file '%1' written, retval: %2", file_path, ret);
	if (compress_package_descriptions && gzip_installed ())
	{
	    y2debug ("compressing %1 file: %2", file_path, SCR::Execute (
		.target.bash, sformat ("gzip %1", file_path)));
	}
    });
    if (ret) // copy the rest of files, generated earlier
    {
	SCR::Execute (.target.bash, sformat (
	    "/bin/rm -f '%1/packages' '%1/packages.DU*' '%1/packages.FL*'",
	    descr_path));
	foreach (string file, [ "packages", "packages.DU", "packages.FL"], {
	    string pth		= tmpdir + "/" + file;
	    y2debug ("processing '%1'", pth);
	    boolean compress	= false;
	    if (!FileUtils::Exists (pth) && FileUtils::Exists (pth + ".gz"))
		pth = pth + ".gz";
	    else if (compress_package_descriptions)
		compress	= true;
	    string cmd = sformat("/bin/cp %1 '%2'", pth, descr_path);
	    SCR::Execute (.target.bash, cmd, $["LANG":"C"]);
	    if (compress)
	    {
		SCR::Execute (.target.bash,
		    sformat ("gzip %1/%2", descr_path, file));
	    }
	});
    }

    string extra_prov	= current_product["extra_prov"]:"";
    if (extra_prov != "" && extra_prov != nil)
	SCR::Write (.target.string, descr_path + "/EXTRA_PROV",extra_prov);

    y2milestone ("... done");
    return ret;
}

/**
 * Generate ARCHIVES.gz, INDEX.gz and ls-lR.gz
 * @param base_path path to base output directory
 */
global boolean GenerateArchiveFiles (string base_path)
{
    if (!Package::Installed ("inst-source-utils") &&
	!FileUtils::Exists ("/usr/bin/mk_listings"))
    {
	y2error ("inst-source-utils not installed and mk_listings not present");
	return false;
    }
    if (!FileUtils::Exists (base_path)) return false;

    map out = (map) SCR::Execute (.target.bash_output, sformat ("cd '%1';mk_listings .",base_path));
    if (out["stderr"]:"" != "")
    {
	y2warning ("mk_listings returns %1", out);
    }
    return true;
}


/**
 * Create the patches files
 * @param base_path path to base output directory
 * @param list with patches file contents
 * @return success
 */
global boolean WritePatchesFiles (string base_path, list<string> p_files)
{
    if (!FileUtils::Exists (base_path)) return false;

    integer i	= 1;
    foreach (string cont, p_files, {
	string file_path = base_path + sformat ("/media.%1/patches", i);
	if (cont != "")
	{
	    SCR::Write (.target.string, file_path, cont);
	}
	i	= i + 1;
    });
    return true;
}
/**
 * Create the products file TODO editor - see ExpertSettingsDialog3
 * @param base_path path to base output directory
 * @return success
 */
global boolean WriteProductsFiles (string base_path, list<string> p_files)
{
    if (!FileUtils::Exists (base_path)) return false;

    integer i	= 1;
    if (p_files == [])	p_files = [ "" ];
    foreach (string cont, p_files, {
	if (cont == "")
	{
	    cont = "/\t" +
		content_map["NAME"]:"" + " " +
		content_map["VERSION"]:"";
	}
	SCR::Write (.target.string,
	    sformat ("%1/media.%2/products", base_path, i), cont);
	i	= i + 1;
    });
    return true;
}

/**
 * Write the media.n/media files
 * @param base_path path to base output directory
 * @param m_files list of media files contents
 * @param next content of nextmedia file
 * @return success
 */
global boolean WriteMediaFiles (string base_path, list<string> m_files, string next)
{
    if (!FileUtils::Exists (base_path)) return false;

    integer i	= 1;
    if (m_files == [])	m_files = [ "" ];
    foreach (string cont, m_files, {
	string media_path = base_path + sformat ("/media.%1", i);
	if (cont == "")
	{
	    string media_id	= "";
	    map out = (map) SCR::Execute (.target.bash_output,
		"date +%Y%m%d%H%M%S");
	    media_id	= deletechars (out["stdout"]:"", "\n");
	    cont = content_map["VENDOR"]:"" + "\n" + media_id;
	    if (i == 1)
		cont	= cont + "\n" + size (m_files);
	}
	SCR::Write (.target.string, media_path + "/media", cont);
	// write nextmedia file if not empty
	if (i == 1 && next != "")
	    SCR::Write (.target.string, media_path + "/nextmedia", next);
	i	= i + 1;
    });
    return true;
}

// write info.txt file
global boolean WriteInfoFile (string info_dir, string info) {

    if (info != "" && info != nil)
	SCR::Write (.target.string, info_dir + "/info.txt", info);
    return true;
}


/**
 * Write the text of available licenses to correct places
 * @path descr_path full path to directory with package descriptions (DESCRDIR)
 * @param base_path full path to base output directory
 * @patram files map of license files and their contents ($[ name : content ])
 */
global boolean WriteLicensesFiles (string descr_path, string base_path, map<string,string> files)
{

    if (!FileUtils::Exists (base_path))
    {
	y2warning ("no %1 directory exists...", base_path);
	return false;
    }
    y2milestone ("writing licenses...");
    boolean ret	= true;
    string cmd	= "";
    foreach (string file, string cont, files, {
	if (cont != "")
	{
	    integer pos	= findlastof (file, ".");
	    if (pos == nil || substring (file, pos) != ".txt")
		file	= file + ".txt";
	    cmd	= cmd + " " + file;
	    ret = ret && SCR::Write (.target.string, tmpdir + "/"+ file ,cont);
	    if (file == "license.txt")
		SCR::Write (.target.string, tmpdir + "/EULA.txt", cont);
	}
    });
    // tar + gzip the licenses into one file
    if (ret && cmd != "")
    {
	cmd     = sformat ("cd %1; tar -czf %2/license.tar.gz license*.txt",
	    tmpdir, base_path);
	map out = (map) SCR::Execute (.target.bash_output, cmd);
	if (out["stderr"]:"" != "")
	{
	    y2warning ("%1 returned %2", cmd, out);
	    ret	= false;
	}
    }
    // merge the license of packages into EULA.txt
    if (!FileUtils::Exists (tmpdir + "/EULA.txt"))
	SCR::Execute (.target.bash, sformat ("touch %1/EULA.txt", tmpdir));
    if (FileUtils::Exists ("/usr/bin/packages2eula.pl"))
    {
	SCR::Execute (.target.bash_output, sformat(
	"/usr/bin/packages2eula.pl -p %1/packages.en -o %2/EULA.txt 2>/dev/null"
	, descr_path, tmpdir));
    }
    if (FileUtils::GetSize (tmpdir + "/EULA.txt") > 0)
	SCR::Execute (.target.bash, sformat ("cp %1/EULA.txt %2/", tmpdir,
	    base_path));

    return ret;
}

/**
 * Write all files with patterns definitions
 * @path descr_path full path to directory with package descriptions (DESCRDIR)
 * @param base_path path to base output directory
 */
global boolean WritePatterns (string descr_path, string base_path) {

    if (!FileUtils::Exists (base_path) || !FileUtils::Exists (descr_path))
    {
	y2warning ("%1 or %2 directory not available...",base_path, descr_path);
	return false;
    }

    boolean ret		= true;
    list<string> names	= [];
    foreach (string name, map pattern, current_product["patterns"]:$[], {
	string filename	= CreatePatternFullName (pattern, true);
	if (filename == "")
	    return;
	names		= add (names, filename);
	string file	= sformat ("=Ver: %1\n\n=Pat: %2\n",
	    pattern["Ver"]:pattern_descr["Ver","defval"]:"",
	    pattern["Pat"]:"");
	pattern	= remove (remove (pattern, "Ver"), "Pat");
	foreach (string key, any val, (map<string,any>) pattern, {
	    map descr		= pattern_descr[key]:$[];
	    // substring (key,0,3) is because of Des.lang, Sum.lang and Cat.lang
	    string shortkey	= substring (key,0,3);
	    if (pattern_descr[shortkey]:$[] != $[] &&
		substring (key, 3, 1) == ".")
		descr		= pattern_descr[shortkey]:$[];
	    if (val == nil || val == "" || val == [] || descr["internal"]:false)
		return;
	    if (file != "")
		file	= file + "\n";
	    if (descr["type"]:"" == "boolean")
		val	= (boolean) val ? "true" : "false";
	    else if (descr["type"]:"" == "package-list")
		val	= mergestring ((list<string>)val, "\n");
	    if (descr["single_line"]:false)
	    {
		file = file + sformat ("=%1: %2\n", key, val);
	    }
	    else
	    {
		file = file + sformat ("+%1:\n%2\n-%1:\n", key, val);
	    }
	});
	y2milestone ("writing pattern %1/%2: %3", descr_path, filename,
	    SCR::Write (.target.string, descr_path + "/" + filename, file)
	);
	if (compress_patterns && gzip_installed ())
	{
	    y2debug ("compressing pattern file: %1", SCR::Execute (
		.target.bash, sformat ("gzip %1/%2",descr_path,filename)));
	}
    });
    if (names != [])
	ret = SCR::Write (.target.string, descr_path + "/patterns",
	    mergestring (names, "\n"));
    return ret;
}

/**
 * Copy the packages from the source directory to target
 * @param in_path source path
 * @param base_path destination directory
 * @return success
 */
global boolean CopyRPMs (string in_path, string base_path) {

    if (in_path == "")
	return true;

    if (!FileUtils::Exists (base_path) || !FileUtils::Exists (in_path))
	return false;
    // packages in the directories with arch name
    if (arch_directories != [])
    {
	foreach (string arch, arch_directories, {
	    string dir	= in_path + "/" + arch;
	    if (FileUtils::Exists (dir))
	    {
		y2milestone ("copying from %1 to %2...", dir, full_data_path);
		SCR::Execute (.target.bash_output,
		    sformat ("/bin/cp -r %1 '%2/'", dir, full_data_path));
	    }
	});
    }
    // packages not in directories but we have asked them for arch's
    else if (available_packages != $[])
    {
	foreach (string arch, list pa, available_packages, {
	    string out_dir	= full_data_path + "/" + arch;
	    if (arch != "ZZZ_imported" && arch != "ZZZ_required" &&
		FileUtils::Exists (out_dir))
	    {
		y2milestone ("copying packages of '%1' architecture", arch);
		// arch_directories will be needed later for CreateMD5SUMS and
		// resign_packages
		arch_directories	= (list<string>)
		    union (arch_directories, [arch]);
		if (size (package2filename) > 0 && arch != "src")
		{
		    y2debug ("package names known");
		    foreach (string p, (list<string>) pa, {
			SCR::Execute (.target.bash, sformat (
			    "/bin/cp %1 '%2/'", package2filename[arch,p]:"", out_dir));
		    });
		}
		else if (size (srcpackage2filename) > 0 && arch == "src")
		{
		    y2debug ("source packages, names known");
		    foreach (string p, (list<string>) pa, {
			SCR::Execute (.target.bash, sformat (
			    "/bin/cp %1 '%2/'", srcpackage2filename[arch,p]:"", out_dir));
		    });
		}
		else
		{
		    y2debug ("package names not known, using wildcard");
		    foreach (string p, (list<string>) pa, {
			SCR::Execute (.target.bash, sformat (
			    "/bin/cp %1/%2*.rpm '%3/'", in_path, p, out_dir));
		    });
		}
	    }
	});
    }
    return true;
}


/**
 * Use BuildService tools to create -release package with product info
 */
global boolean GenerateReleasePackage (string base_path) {

    if (!generate_release_package)
    {
	y2milestone ("release package should not be generated");
	return true;
    }
    if (!Package::Install ("obs-productconverter"))
    {
	y2error ("obs-productconverter not installed, not generating -release");
	return false;
    }
    if (!FileUtils::Exists (base_path))
	return false;

    // release packages names and architectures
    map<string,string> release_packages	= $[];

    // 1. update product_xml map using product_info and content,
    // write the result into temporary .prod file
    string name	= content_map["NAME"]:"add-on";

    map submap	= product_xml["product",0]:$[];

    submap["id"]			= name;
    submap["name",0, content_key]	= name;
    submap["version",0, content_key]	= content_map["VERSION"]:"1.0";
    submap["vendor",0, content_key]	= content_map["VENDOR"]:"";

    foreach (string key, ["release", "summary", "description"], {
	if (product_info[key,"value"]:"" == "")
	    product_info[key,"value"]	= (key == "release") ? "0" : name;
	submap[key,0,content_key]=product_info[key,"value"]:"";
    });

    if (product_info["releasenotes","value"]:"" != "")
    {
	integer i	= -1;
	foreach (map url, submap["urls",0,"url"]:[], {
	    i	= i + 1;
	    if (url["name"]:"" == "releasenotes")
	    {
		submap["urls",0,"url",i,content_key]	= product_info["releasenotes","value"]:"";
	    }
	});
	if (i == -1)
	{
	    submap["urls"]	= [ $[
		"url"	: [ $[
		    "name"		: "releasenotes",
		    content_key	: product_info["releasenotes","value"]:"",
		]],
	    ]];
	}
    }
    // write the dependency stuff
    list<map> dependency	= [];
    foreach (string key, map desc, product_info, {
	if (desc["type"]:"" == "dependency")
	{
	    foreach (map dep, (list<map>) desc["value"]:[], {
		dependency = add (dependency, add (dep, "relationship", key));
	    });
	}
    });
    list mediasets	= [];
    if (size (dependency) > 0)
    {
	mediasets	= [ $[
	    "media"	: [ $[
		"productdependency"	: dependency,
		"type"		: product_info["media type","value"]:"dvd",
		"flavor"	: product_info["flavor","value"]:"dvd",
		"name"		: name,
		"product"	: name
	    ]],
	]];
    }

    product_xml	= $[
	"productdefinition"	: [ $[
	    "products"	: [
		$[
		    "product"	: [ submap ]
		],
	    ],
	    "mediasets"	: mediasets
	]],
    ];

    string prod_file_path	= sformat ("%1/%2.product", tmpdir, name);

    SCR::Write (.anyxml, $[
        "file"  : prod_file_path,
	"xml"	: product_xml,
	"args"	:	$[
	    "XMLDecl"		: "<?xml version=\"1.0\" encoding=\"UTF-8\"?>",
	    "ForceContent"	: 1,
	    "ForceArray"	: 1,
	    "KeepRoot"		: 1,
	    "ContentKey"	: content_key,
	    "KeyAttr"		: [],
	]
    ]);
    string product_dir	= tmpdir + "/" + name;
    SCR::Execute (.target.mkdir, product_dir);

    // 2. call bs_productconvert to generate a spec file for -release package
    map out	= (map) SCR::Execute (.target.bash_output, sformat (
	"/usr/lib/obs/server/bs_productconvert %1 %2 %3",
	prod_file_path, product_dir, name));

    // 3. build the release package from generated .spec file
    string cmd	= sformat (
	"rpmbuild -bb `find -L %1 -name %2-release.spec`", tmpdir, name);

    if (out["exit"]:0 != 0)
    {
	y2error ("rpmbuild failed with %1", out["stderr"]:"");
	SCR::Execute (.target.remove, prod_file_path);
	SCR::Execute (.target.bash, sformat ("rm -rf '%1'", product_dir));
	return false;
    }

    out     = (map) SCR::Execute (.target.bash_output, cmd, $["LANG":"C"]);
    if (out["exit"]:0 != 0)
    {
	y2error ("command '%1' failed with: \n%2", cmd, out["stderr"]:"");
    }
    else
    {
	foreach (string line, splitstring (out["stdout"]:"", "\n"), {
	    if (size (line) > 8 && substring (line, 0, 7)  == "Wrote: ")
	    {
		list ll = splitstring (line, " \t\n");
		string package	= ll[1]:"";
		if (package != "" && FileUtils::Exists (package))
		{
		    y2milestone ("release package: %1", package);
		    out = (map) SCR::Execute (.target.bash_output,
			sformat ("rpm -q -p %1 --qf \"%%{ARCH}\"", package));
		    release_packages[package]	= out["stdout"]:"";
		}
	    }
	});
    }
    // 4. copy the release package to the correct place
    foreach (string package_path, string arch, release_packages, {
	// create arch directory if it does not exist
	if (!contains (arch_directories, arch))
	{
	    arch_directories	= add (arch_directories, arch);
	    SCR::Execute (.target.mkdir, full_data_path + "/" + arch);
	}
	SCR::Execute (.target.bash, sformat ("/bin/cp -r %1 '%2/%3'",
	    package_path, full_data_path, arch));
    });
import "Popup";
Popup::Message ("built");
    // 5. delete the tmp files, so it doesn't mess possible next builds
    SCR::Execute (.target.remove, prod_file_path);
    SCR::Execute (.target.bash, sformat ("rm -rf '%1'", product_dir));
    return true;
}


/**
 * Write the modification of installation workflow
 * @param base_path path to base output directory
 * @param desc_path path to workflow description file
 * @param packages list with paths of packages to be included in y2update.tgz
 * @param y2update path to existing y2update.tgz
 */
boolean WriteWorkflow (string base_path,string desc_path, list<string> packages,
		       string y2update_p)
{
    if (!FileUtils::Exists (base_path)) return false;

    boolean ret = true;
    if (desc_path != "" && FileUtils::Exists (desc_path))
    {
	y2milestone ("writing %1 as %2/installation.xml", desc_path, base_path);
	SCR::Execute (.target.bash, sformat ("cp '%1' '%2/installation.xml'",
	    desc_path, base_path));
    }
    if (y2update_p != "")
    {
	SCR::Execute (.target.bash, sformat ("cp '%1' '%2/y2update.tgz'",
	    y2update_p, base_path));
    }
    else if (packages != [])
    {
	string y2update_dir	= tmpdir + "/y2update";
	SCR::Execute (.target.mkdir, y2update_dir);
	foreach (string p, packages, {
	    y2milestone ("extracting %1", p);
	    string cmd = sformat ("cd '%1'; rpm2cpio %2 | cpio -imud 2>&1",
		y2update_dir, p);
	    y2debug ("extracting rpm: %1", cmd);
	    map out = (map) SCR::Execute (.target.bash_output, cmd);
	    if (out["stderr"]:"" != "")
	    {
		y2warning ("%1 returned %2", cmd, out);
	    }
	});
	string cmd = sformat ("cd '%2'; tar -czf '%1/y2update.tgz' .",
	    base_path, y2update_dir);
	y2debug ("tar cmd: %1", cmd);
	map out = (map) SCR::Execute (.target.bash_output, cmd);
	if (out["stderr"]:"" != "")
	{
	    y2warning ("%1 returned %2", cmd, out);
	    ret	= false;
	}
    }
    return ret;
}

/**
 * Generate Changelog for the product
 * @param base_path base output path
 */
boolean GenerateChangelog (string base_path)
{
    if (!Package::Installed ("inst-source-utils") &&
	!FileUtils::Exists ("/usr/bin/mk_changelog"))
    {
	y2error("inst-source-utils not installed and mk_changelog not present");
	return false;
    }
    if (!FileUtils::Exists (base_path)) return false;

    map out = (map) SCR::Execute (.target.bash_output,
	sformat ("cd '%1'; mk_changelog",base_path),
	$[ "ROOT_ON_CD" : content_map["DATADIR"]:""]);
    if (out["stderr"]:"" != "")
    {
	y2warning ("mk_changelog returns %1", out);
    }
    return true;

}

/**
 * Generate servicepack.tar.gz archive for bootable media
 * @param base_path base output path
 */
boolean WriteServicepackArchive (string base_path)
{
    if (!FileUtils::Exists (base_path)) return false;

    boolean ret = true;
    if (!bootable) return ret;

    string spdir	= tmpdir + "/servicepack";
    SCR::Execute (.target.mkdir, spdir);

    SCR::Execute (.target.bash,
	sformat ("cp %1/content* '%2/'", base_path, spdir));

    SCR::Execute (.target.bash,
	sformat ("cp %1/gpg-pubkey* '%2/'", base_path, spdir));

    SCR::Execute (.target.bash,
	sformat ("cp -r %1/media.1 '%2/'", base_path,spdir));

    // copy descriptions (with the stucture)
    string descr_path = sformat ("%1/%2", spdir, content_map["DESCRDIR"]:"");
    SCR::Execute (.target.mkdir, descr_path);
    SCR::Execute (.target.bash,
	sformat("cp %1/* '%2/'", full_descr_path, descr_path));

    if (current_product["workflow_path"]:"" != "")
	SCR::Execute (.target.bash, sformat("cp '%1/installation.xml' '%2/'",
	    base_path, spdir));

    if (FileUtils::Exists (base_path + "/y2update.tgz"))
	SCR::Execute (.target.bash, sformat("cp '%1/y2update.tgz' '%2'",
	    base_path, spdir));

    // finally, create the archive
    string cmd = sformat ("cd '%1'; tar -czf '%2/servicepack.tar.gz' .",
	spdir, base_path);
    y2debug ("tar cmd: %1", cmd);
    map out = (map) SCR::Execute (.target.bash_output, cmd);
    if (out["stderr"]:"" != "")
    {
	y2warning ("%1 returned %2", cmd, out);
	ret	= false;
    }
    return ret;
}

// helper to check if directory contains any files (-type f)
boolean dir_has_files (string dir) {

    if (!FileUtils::Exists (dir)) return false;

    map out = (map) SCR::Execute (.target.bash_output,
	sformat ("cd '%1'; find -maxdepth 1 -type f | wc -l", dir));
    integer count = tointeger(deletechars(out["stdout"]:"0","\n"));
    return (count != nil && count > 0);
}

/**
 * Create MD5SUMS files
 * @return success
 */
global boolean CreateMD5SUMS (string base_path) {

    if (!FileUtils::Exists (base_path)) return false;

    // after CopyRPMs, arch_directories contains list of directories with RPM's
    list<string> dirs_for_md5 = maplist (string arch_dir, arch_directories, {
	return full_data_path + "/" + arch_dir;
    });
    dirs_for_md5	= add (dirs_for_md5, full_descr_path);
    foreach (string full_path, dirs_for_md5, {
	if (dir_has_files (full_path))
	{
	    y2milestone ("creating MDBSUM in %1", full_path);
	    // whole dir was copied -> also with original MD5SUMS
	    if (FileUtils::Exists (full_path + "/MD5SUMS"))
	    {
		SCR::Execute (.target.bash, sformat("cd '%1'; chmod +w . MD5SUMS; rm MD5SUMS", full_path));
	    }
	    string command = sformat("cd '%1'; md5sum -- * > MD5SUMS", full_path);
	    map out =
		(map)SCR::Execute (.target.bash_output, command, $["LANG":"C"]);
	    if (out["exit"]:0 != 0)
		y2error ("%1 failed: %2", command, out);
	}
    });

    // sha1sums of descriptions
    map out = (map) SCR::Execute (.target.bash_output, sformat ("ls -A1 '%1'", full_descr_path));
    foreach (string file, splitstring (out["stdout"]:"", "\n"), {
	if (file == "") return;
	y2milestone ("creating sha1sum of %1", file);
	out = (map) SCR::Execute (.target.bash_output,
	    sformat ("cd '%1' && sha1sum -- %2", full_descr_path, String::Quote (file)),
	    $["LANG" : "C"]);
	string command	= sformat ("echo 'META SHA1 %1' >> '%2/content'",
	    deletechars (out["stdout"]:"", "\n"), base_path);
	SCR::Execute (.target.bash, command, $["LANG" : "C"]);
    });

    // sha1sums of the rest of interesting files
    foreach (string file, [ "installation.xml", "license.tar.gz",
	"media.1/info.txt"],
    {
	if (FileUtils::Exists (base_path + "/" + file))
	{
	    y2milestone ("creating sha1sum of %1", file);
	    out = (map) SCR::Execute (.target.bash_output,
		sformat ("cd '%1' && sha1sum -- %2", base_path, String::Quote (file)), $["LANG" : "C"]);
	    string command = sformat ("echo 'HASH SHA1 %1' >> '%2/content'",
		deletechars (out["stdout"]:"", "\n"), base_path);
	    SCR::Execute (.target.bash, command, $["LANG" : "C"]);
	}
    });
    return true;
}

/**
 * Report the error with failed gpg and ask for possible new
 * entering of pw
 * @param string message from gpg
 * @param boolean if we are asking because of signing failure
 */
string AskForPassphrase (string message, boolean failure) {

    string pw	= nil;
    term info_term	= failure ? `VBox (
	`HSpacing (70),
	// error label
	`Left (`Label (_("Signing of the product failed."))),
	message == "" ?
	    `VSpacing (0) :
	    `RichText (mergestring (splitstring (
		String::EscapeTags (message),"\n"),"<br>")
	    )
    ) : `VSpacing ();
    term input_term	= failure ?  `HBox (
		`Left (`CheckBox (`id (`again), `opt (`notify),
		    // checkbox label
		    _("Try again with different passphrase"))),
		`Password (`id (`pw1), "")
    ) : `VBox (
	`Password (`id (`pw1), message)
    );
    UI::OpenDialog (`opt(`decorated), `HBox (`HSpacing (0.5),
	`VBox (
	    info_term,
	    input_term,
	    `PushButton (`id(`ok),`opt(`key_F10), Label::OKButton()),
	    `VSpacing (0.5)
	), `HSpacing (0.5))
    );
    UI::ChangeWidget (`id (`pw1), `Enabled, !failure);

    any ret	= `cancel;
    repeat
    {
	ret	= UI::UserInput ();
	if (ret == `again)
	{
	    boolean enabled	= (boolean)UI::QueryWidget(`id(`pw1), `Enabled);
	    UI::ChangeWidget (`id (`pw1), `Enabled, !enabled);
	}
	if (ret == `ok)
	{
	    if (UI::QueryWidget (`id(`pw1), `Enabled) == true)
	    {
		pw	= (string) UI::QueryWidget (`id(`pw1), `Value);
	    }
	}
    } until (ret == `ok || ret == `cancel);

    UI::CloseDialog ();
    return pw;
}

/**
 * Sign current Add-On product
 * @param base_path path to target product directory
 * @param key GPG key to sign with
 */
global boolean SignAddOn (string base_path, string key) {

    string passphrase	= passphrases[key]:"";
    if (key == "" || passphrase == "")
    {
	y2warning ("No GPG key or passphrase provided - signing skipped");
	return true;
    }

    string command = sformat ("gpg --list-secret-keys %1|grep '^sec'|sed -e 's/.*\\///;s/ .*//g;'|head -n 1", key);
    map out = (map)SCR::Execute (.target.bash_output, command, $["LANG" : "C"]);
    string local_key	= deletechars (out["stdout"]:"0","\n");

    out = (map)SCR::Execute (.target.bash_output, sformat ("gpg --list-secret-keys --with-colons %1| grep %2 | gawk -F: '{print $5}'| sed 's/........$//g'", key, local_key));
    string big_key	= deletechars (out["stdout"]:"0","\n");

    // save the passphrase
    string pw_path	= tmpdir + "/pw";
    SCR::Write (.target.string, pw_path, passphrase);

    // export the key:
    command = sformat ("gpg --export -a %1 > '%2/gpg-pubkey-%3-%1.asc'",
	local_key, base_path, big_key);
    SCR::Execute (.target.bash, command, $["LANG" : "C"]);

    // make a sha1 sum of that key (content file is modified last time)
    out = (map) SCR::Execute (.target.bash_output,
	sformat ("cd '%1'; ls -A1 gpg-pubkey*", base_path));

    foreach (string file, splitstring (out["stdout"]:"", "\n"), {
	if (file == "") return;
	out = (map) SCR::Execute (.target.bash_output,
	    sformat ("cd '%1' && sha1sum -- %2", base_path, String::Quote (file)),
	    $["LANG" : "C"]);
	string command	= sformat ("echo 'KEY SHA1 %1' >> '%2/content'",
	    deletechars (out["stdout"]:"", "\n"), base_path);
	SCR::Execute (.target.bash, command, $["LANG" : "C"]);
    });
    y2milestone ("signing content file...");
    while (true)
    {
	// sign the content file
	SCR::Execute (.target.bash, sformat ("rm -f '%1/content.asc'",
	    base_path));
	out	= (map) SCR::Execute (.target.bash_output, sformat("gpg --batch --no-tty --passphrase-fd 0 --detach-sign -u %1 -a '%2/content' < %3",
	    local_key, base_path, pw_path)
	);
	if (out["exit"]:0 != 0)
	{
	    if (Mode::commandline ())
		Report::Error (out["stderr"]:"");
	    else
	    {
		passphrase	= AskForPassphrase (out["stderr"]:"", true);
		if (passphrase != nil)
		{
			SCR::Write (.target.string, pw_path, passphrase);
			continue;
		}
	    }
	    SCR::Execute (.target.remove, pw_path);
	    return false;
	}
	else break;
    }
    y2milestone ("... done");

    SCR::Execute (.target.bash,
	sformat("gpg --export -a %1 > '%2/content.key'",local_key, base_path));

    // sign the packages
    if (current_product["resign_packages"]:false)
    {
	y2milestone ("signing the packages...");
	string expect	= tmpdir + "/sign.ex";
	SCR::Write (.target.string, expect,
	    sformat (expect_script, key, passphrase));
	list<string> dirs = maplist (string arch_dir, arch_directories, {
	    return full_data_path + "/" + arch_dir;
	});
	foreach (string full_path, dirs, {
	    if (dir_has_files (full_path))
	    {
		string cmd = sformat ("LANG=C expect %1 %2/*.rpm", expect, full_path);
		out = (map) SCR::Execute (.target.bash_output, cmd);
	    }
	});
	y2milestone ("... done");
	SCR::Execute (.target.bash, sformat ("rm %1", expect));
	// after signing packages checksums have changed:
	// run create_package_descr again and take new 'packages' file
	y2milestone ("updating packages descriptions...");
	string cmd = sformat("/usr/bin/create_package_descr -d %1 -C -F -o %2",
	    full_data_path, tmpdir);
	if (SCR::Execute (.target.bash, cmd, $["LANG":"C"]) == 0)
	{
	    cmd = sformat ("/bin/cp %1/packages '%2'", tmpdir, full_descr_path);
	    SCR::Execute (.target.bash, cmd, $["LANG":"C"]);
	    if (compress_package_descriptions)
	    {
		SCR::Execute (.target.bash,
		    sformat ("gzip %1/packages", full_descr_path));
	    }
	}
	else
	{
	    y2warning ("'%1' failed", cmd);
	}
	y2milestone ("... done");
    }

    // sign products file
    string products_path = full_media_paths[0]:"" + "/products";
    if (FileUtils::Exists (products_path))
    {
	y2milestone ("signing products file...");
	SCR::Execute (.target.bash, sformat ("rm -f '%1.asc'", products_path));
	SCR::Execute (.target.bash,
	    sformat("gpg --batch --no-tty --passphrase-fd 0 --detach-sign -u %1 -a '%2' < %3",
	    local_key, products_path, pw_path));
	SCR::Execute (.target.bash,
	    sformat("gpg --export -a %1 > '%2.key'", local_key,products_path));
	y2milestone ("... done");
    }
    SCR::Execute (.target.remove, pw_path);
    return true;
}

/**
 * Create directory.yast files (the last step)
 * @return success
 */
global boolean CreateDirectoryYaSTFiles (string base_path) {

    if (!FileUtils::Exists (base_path)) return false;

    y2milestone ("creating directory.yast files...");
    foreach (string dir, (list<string>) merge (
	[base_path, full_descr_path], full_media_paths),
    {
	SCR::Execute (.target.bash_output, sformat ("cd '%1'; ls -A1 -p | grep -v 'directory.yast' > directory.yast", dir), $["LANG" : "C"]);
    });
    y2milestone ("... done");
    return true;
}

/**
 * Create an ISO image of the product
 */
global boolean CreateISOImage (string dir_path, string iso_p, string name) {

    if (!current_product["iso"]:false) return true;

    if (!FileUtils::Exists (dir_path) || !FileUtils::Exists (iso_p)) return false;

    if (name == "")
	name	= sformat ("%1-%2",
	    tolower (content_map["NAME"]:"addon"), content_map["VERSION"]:"");
    if (!issubstring (name, ".iso"))
	name	= name + ".iso";
    current_product["iso_name"]	= name; // ??

    y2milestone ("creating iso image '%1/%2' from '%3' with mkisofs...",
	iso_p, name, dir_path);

    // possible options -allow-leading-dots
    string cmd	= sformat("mkisofs -r -J -l -o '%1/%2' '%3'",
	iso_p, name, dir_path);
    map out	= (map) SCR::Execute (.target.bash_output, cmd);
    if (out["exit"]:0 != 0)
    {
	y2warning ("%1 returned %2", cmd, out);
    }
    y2milestone ("... done");
    return true;
}

/**
 * Reset all settings related to current product
 */
global void ResetCurrentProduct () {

    current_product	= current_product_skel;
    generate_descriptions = false;
    clone		= false;

    available_packages  = $[];
    package2filename	= $[];
    srcpackage2filename = $[];

    // TODO move into current_product as well?
    content		= [];
    content_map		= $[];

    // reset global variables, that are generated for each product
    full_media_paths	= [];
    full_descr_path	= "";
    full_data_path	= "";
}

/**
 * save the data with current configuration into global list
 * + reset the current product map
 */
global void CommitCurrentProduct () {

    y2milestone ("saving current product to the global list");

    map product_info_values	= $[];
    foreach (string key, map desc, product_info, {
	if (desc["value"]:nil != nil)
	    product_info_values[key]	= $[
		"value"	: desc["value"]:nil,
	    ];
    });
    map modified_product	= union (current_product, $[
	"content_map"		: content_map,
	"product_info_values"	: product_info_values,
	"generate_release_package"	: generate_release_package,
	"available_packages"	: available_packages,
	"arch_directories"	: arch_directories,
	"package2filename"	: package2filename,
	"srcpackage2filename"	: srcpackage2filename,
	"generated"		: true,// Commit is after everything was entered
    ]);
    if (selected_product == -1)
	add_on_products = add (add_on_products, modified_product);
    else
    {
	integer i	= -1;
	add_on_products	= maplist (map product, add_on_products, {
	    i	= i + 1;
	    return (i == selected_product) ? modified_product : product;
	});
    }
    ResetCurrentProduct ();
    modified	= true;
}

// select the given product:
// fill in the global variables specific for the given product
global void SelectProduct (map product) {

    current_product	= product;
    content_map		= product["content_map"]:$[];
    map product_info_values	= product["product_info_values"]:$[];

    foreach (string key, map desc, product_info_descr, {
	if (product_info_values[key,"value"]:nil != nil)
	{
	    desc["value"]	= product_info_values[key,"value"]:nil;
	}
	product_info[key]	= desc;
    });

    generate_release_package	= product["generate_release_package"]:false;

    // generate content from content_map
    content	= [];
    foreach (string key, map entry, content_descr, {
	if (content_map[key]:"" != "")
	    entry["value"]	= content_map[key]:"";
	content	= add (content, entry);
    });
    foreach (string key, string val, content_map, {
	if (!haskey (content_descr, key) && issubstring (key, "."))
	{
	    y2debug ("key %1 not in descr", key);
	    map entry	=
		content_specials[substring (key,0,findfirstof (key,"."))]:$[];
	    entry["key"]	= key;
	    entry["value"]	= val;
	    content = add (content, entry);
	}
    });
    available_packages	= product["available_packages"]:$[];
    arch_directories	= product["arch_directories"]:[];
    package2filename	= product["package2filename"]:$[];
    srcpackage2filename	= product["srcpackage2filename"]:$[];
}

/**
 * Write all AddOn products configurations
 */
global boolean Write () {

    add_on_products	= maplist (map product, add_on_products, {
	// these could be generated, no need to save...
	foreach (string key, ["available_packages", "arch_directories",
	    "package2filename", "srcpackage2filename", "generated"], {
	    if (haskey (product, key))
		product	= remove (product, key);
	});
	return product;
    });
    y2milestone ("writing list of configured products");
    return SCR::Write (.target.ycp, add_on_products_file, add_on_products);
}

/**
 * read the user's ID for given GPG key
 */
global string GetKeyUID (string key) {

    map out         = (map) SCR::Execute (.target.bash_output, sformat ("gpg --list-secret-keys %1 | grep uid | sed -e 's/^uid[ ]*//'", key));
    string name	= deletechars (out["stdout"]:"", "\n");
    return name == nil ? "" : name;
}

/**
 * prepare the data of current product for a build
 * (neccessary because input packages could get changed)
 */
global boolean PrepareBuild () {

    if (!current_product["generated"]:false)
    {
	FillContentDefaults ();
	// TODO not everything generated by FillContentDefaults is needed?
    }
    string key	= current_product["gpg_key"]:"";
    if (current_product["ask_for_passphrase"]:false &&
	key != "" && passphrases[key]:"" == "" && !Mode::commandline ())
    {
	string name	= GetKeyUID (key);
	// ask for pw now %1 is key id, %2 user name
	passphrases[key]	= AskForPassphrase (
	    sformat (_("Enter passphrase for GPG key %1
(%2)"), key, name), false);
    }
}

/**
 * Write all add-on-creator settings
 * @return true on success
 */
global boolean BuildAddOn () {

    string base_output_path	= current_product["base_output_path"]:"";

    // AddOnCreator Build dialog caption
    string caption	= _("Creating the Add-On");

    list<string> stages	= [
	    // Progress stage
	    _("Write the content file"),
	    // Progress stage
	    _("Create the structure of the add-on"),
	    // Progress stage
	    _("Write the patterns"),
	    // Progress stage
	    _("Copy the packages"),
	    // Progress stage
	    _("Generate the release package"),
	    // Progress stage
	    _("Create MD5 sums"),
	    // Progress stage
	    _("Sign resulting product"),
    ];
    list<string> steps	= [
	    // Progress step
	    _("Writing the content file..."),
	    // Progress step
	    _("Creating the structure of the add-on..."),
	    // Progress stage
	    _("Writing the patterns..."),
	    // Progress step
	    _("Copying the packages..."),
	    // Progress stage
	    _("Generating the release package..."),
	    // Progress step
	    _("Creating MD5 sums..."),
	    // Progress stage
	    _("Signing resulting product..."),
    ];

    if (current_product["iso"]:false)
    {
	// Progress stage
	stages	= add (stages, _("Create ISO image"));
	// Progress step
	steps	= add (steps, _("Creating ISO image..."));
    }
    // Progress finished
    steps   = add (steps, _("Finished"));

    Progress::New (caption, " ", size (stages), stages, steps, "");

    Progress::NextStage();

    if (current_product["iso"]:false)
    {
	string iso_path	= current_product["iso_path"]:"";
	if (iso_path == "")
	{
	    current_product["iso_path"]	= base_output_path;
	    if (!only_sign_product)
	    {
		base_output_path= tmpdir + "/output";
		SCR::Execute (.target.mkdir, base_output_path);
	    }
	}
	else if (!FileUtils::Exists (iso_path))
	    SCR::Execute (.target.mkdir, iso_path);
    }

    if (only_sign_product)
    {
	GenerateDirectories (base_output_path);
	Progress::NextStage();
	Progress::NextStage();
	Progress::NextStage();
	Progress::NextStage();
    }
    else
    {
	if (!WriteContentFile (base_output_path, content))
	{
	    // Error message (do not translate 'content'
	    Report::Error (_("Cannot write content file."));
	    return false;
	}

	WriteStringFiles (base_output_path,
	    current_product["readme_files"]:$[]);
	WriteStringFiles (base_output_path,
	    current_product["copying_files"]:$[]);
	WriteStringFiles (base_output_path,
	    current_product["copyright_files"]:$[]);

	Progress::NextStage();

	if (!CreateAddOnStructure (base_output_path))
	{
	    // Error message
	    Report::Error (_("Cannot create the output directory structure."));
	    return false;
	}

	WritePatchesFiles (base_output_path,
	    current_product["patches_files"]:[]);

	WriteProductsFiles (base_output_path,
	    current_product["products_files"]:[]);

	WriteMediaFiles (base_output_path,
	    current_product["media_files"]:[],
	    current_product["nextmedia"]:"");

	WriteInfoFile (full_media_paths[0]:"",
	    current_product["info"]:"");

	Progress::NextStage();

	WritePatterns (full_descr_path, base_output_path);

	Progress::NextStage();

	CopyRPMs (current_product["rpm_path"]:"", base_output_path);

	Progress::NextStage();

	GenerateReleasePackage (base_output_path);

	WritePackageDescriptions (
	    full_descr_path,
	    current_product["packages_descr"]:$[]);

	WriteLicensesFiles (full_descr_path, base_output_path,
	    current_product["license_files"]:$[]);

	WriteWorkflow (base_output_path,
	    current_product["workflow_path"]:"",
	    current_product["y2update_packages"]:[],
	    current_product["y2update_path"]:"");

	Progress::NextStage();

	GenerateArchiveFiles (base_output_path);

	CreateMD5SUMS (base_output_path);
    }

    Progress::NextStage();

    if (current_product["changelog"]:false)
	GenerateChangelog (base_output_path);

    WriteServicepackArchive (base_output_path);

    if (!SignAddOn (base_output_path, current_product["gpg_key"]:""))
	return false;

    CreateDirectoryYaSTFiles (base_output_path);

    if (current_product["iso"]:false)
    {
	Progress::NextStage();
	CreateISOImage (base_output_path,
	    current_product["iso_path"]:"",
	    current_product["iso_name"]:"");
    }

    Progress::NextStage();

    ResetCurrentProduct ();

    return true;
}

/**
 * Export the settings about current Add-On product
 */
global map Export () {

    y2warning ("not implemented");
    return $[];
}

global boolean Import (map settings) {

    y2warning ("not implemented");
    return false;
}

/* EOF */
}
